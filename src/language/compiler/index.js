/**
 * TodoLang Compiler - Transpiles AST to JavaScript
 *
 * This compiler converts TodoLang AST nodes into JavaScript code.
 * It generates JavaScript classes for components, models, and services,
 * and handles state management, JSX rendering, and method compilation.
 */

import {
  ProgramNode, ComponentNode, StateNode, PropertyNode, MethodNode,
  ComputedNode, RenderNode, ModelNode, ServiceNode, ParameterNode,
  TypeNode, BlockNode, ExpressionStatementNode, IfNode, ForNode,
  WhileNode, ReturnNode, BreakNode, ContinueNode, VariableDeclarationNode,
  VariableDeclaratorNode, ArrowFunctionNode, NewExpressionNode,
  BinaryExpressionNode, UnaryExpressionNode, AssignmentNode,
  ConditionalNode, CallNode, MemberNode, IdentifierNode, ThisNode,
  StringLiteralNode, NumberLiteralNode, BooleanLiteralNode,
  NullLiteralNode, ArrayLiteralNode, ObjectLiteralNode,
  ObjectPropertyNode, JSXElementNode, JSXAttributeNode,
  JSXTextNode, JSXExpressionNode
} from '../parser/index.js';

export class CompilerError extends Error {
  constructor(message, node = null) {
    super(message);
    this.name = 'CompilerError';
    this.node = node;
    this.location = node ? node.location : null;
  }
}

export class SourceMap {
  constructor() {
    this.mappings = [];
    this.sources = [];
    this.names = [];
  }

  addMapping(generatedLine, generatedColumn, sourceLine, sourceColumn, sourceName = null) {
    this.mappings.push({
      generatedLine,
      generatedColumn,
      sourceLine,
      sourceColumn,
      sourceName
    });
  }

  generate() {
    // Simplified source map generation
    return {
      version: 3,
      sources: this.sources,
      names: this.names,
      mappings: this.encodeMappings()
    };
  }

  encodeMappings() {
    // Simplified mapping encoding - in a real implementation,
    // this would use VLQ encoding
    if (this.mappings.length === 0) {
      return '';
    }
    return this.mappings.map(m =>
      `${m.generatedLine},${m.generatedColumn},${m.sourceLine},${m.sourceColumn}`
    ).join(';');
  }
}

export class TodoLangCompiler {
  constructor(options = {}) {
    this.options = {
      generateSourceMaps: true,
      minify: false,
      target: 'es6',
      ...options
    };
    this.sourceMap = new SourceMap();
    this.output = [];
    this.indentLevel = 0;
    this.currentLine = 1;
    this.currentColumn = 1;
  }

  /**
   * Compile AST to JavaScript code
   */
  compile(ast) {
    if (!ast || ast.type !== 'Program') {
      throw new CompilerError('Expected Program AST node');
    }

    this.output = [];
    this.indentLevel = 0;
    this.currentLine = 1;
    this.currentColumn = 1;

    // Add runtime imports and setup
    this.emitLine('// Generated by TodoLang Compiler');
    this.emitLine('// Do not edit this file directly');
    this.emitLine('');
    this.emitLine('import { TodoLangRuntime, Component, StateManager, VirtualDOM } from "./runtime/index.js";');
    this.emitLine('');

    // Compile all declarations
    for (const declaration of ast.declarations) {
      this.compileDeclaration(declaration);
      this.emitLine('');
    }

    const code = this.output.join('\n');

    if (this.options.generateSourceMaps) {
      return {
        code,
        sourceMap: this.sourceMap.generate()
      };
    }

    return { code };
  }

  /**
   * Compile a declaration (component, model, or service)
   */
  compileDeclaration(node) {
    this.addSourceMapping(node);
    switch (node.type) {
      case 'Component':
        return this.compileComponent(node);
      case 'Model':
        return this.compileModel(node);
      case 'Service':
        return this.compileService(node);
      default:
        throw new CompilerError(`Unknown declaration type: ${node.type}`, node);
    }
  }

  /**
   * Compile a component declaration
   */
  compileComponent(node) {
    this.emitLine(`export class ${node.name} extends Component {`);
    this.indent();

    // Generate constructor with state initialization
    if (node.stateDeclaration) {
      this.emitLine('constructor(props = {}) {');
      this.indent();
      this.emitLine('super(props);');
      this.emitLine('this.initializeState();');
      this.dedent();
      this.emitLine('}');
      this.emitLine('');

      // Generate state initialization method
      this.compileStateInitialization(node.stateDeclaration);
    } else {
      this.emitLine('constructor(props = {}) {');
      this.indent();
      this.emitLine('super(props);');
      this.dedent();
      this.emitLine('}');
      this.emitLine('');
    }

    // Compile computed properties
    for (const computed of node.computedProperties) {
      this.compileComputedProperty(computed);
    }

    // Compile methods
    for (const method of node.methods) {
      this.compileMethod(method);
    }

    // Compile render method
    if (node.renderMethod) {
      this.compileRenderMethod(node.renderMethod);
    }

    this.dedent();
    this.emitLine('}');
  }

  /**
   * Compile state initialization
   */
  compileStateInitialization(stateNode) {
    this.emitLine('initializeState() {');
    this.indent();
    this.emitLine('this.state = this.createReactiveState({');
    this.indent();

    for (let i = 0; i < stateNode.properties.length; i++) {
      const property = stateNode.properties[i];
      const isLast = i === stateNode.properties.length - 1;

      let defaultValue = 'undefined';
      if (property.defaultValue) {
        defaultValue = this.compileExpression(property.defaultValue);
      } else if (property.type) {
        defaultValue = this.getDefaultValueForType(property.type);
      }

      this.emit(`${property.name}: ${defaultValue}`);
      if (!isLast) this.emit(',');
      this.emitLine('');
    }

    this.dedent();
    this.emitLine('});');
    this.dedent();
    this.emitLine('}');
    this.emitLine('');
  }

  /**
   * Get default value for a type
   */
  getDefaultValueForType(typeNode) {
    if (typeNode.isArray) {
      return '[]';
    }

    switch (typeNode.name) {
      case 'string': return '""';
      case 'number': return '0';
      case 'boolean': return 'false';
      case 'Date': return 'new Date()';
      default: return 'null';
    }
  }

  /**
   * Compile a computed property
   */
  compileComputedProperty(node) {
    this.emitLine(`get ${node.name}() {`);
    this.indent();

    for (const statement of node.body) {
      this.compileStatement(statement);
    }

    this.dedent();
    this.emitLine('}');
    this.emitLine('');
  }

  /**
   * Compile a method
   */
  compileMethod(node) {
    const staticKeyword = node.isStatic ? 'static ' : '';
    const params = node.parameters.map(p => p.name).join(', ');

    this.emitLine(`${staticKeyword}${node.name}(${params}) {`);
    this.indent();

    for (const statement of node.body) {
      this.compileStatement(statement);
    }

    this.dedent();
    this.emitLine('}');
    this.emitLine('');
  }

  /**
   * Compile render method
   */
  compileRenderMethod(node) {
    this.emitLine('render() {');
    this.indent();

    // Find the JSX return statement
    for (const statement of node.body) {
      if (statement.type === 'ExpressionStatement' &&
          statement.expression.type === 'JSXElement') {
        this.emitLine('return ' + this.compileJSXElement(statement.expression) + ';');
      } else if (statement.type === 'Return' &&
                 statement.expression &&
                 statement.expression.type === 'JSXElement') {
        this.emitLine('return ' + this.compileJSXElement(statement.expression) + ';');
      } else {
        this.compileStatement(statement);
      }
    }

    this.dedent();
    this.emitLine('}');
    this.emitLine('');
  }

  /**
   * Compile a model declaration
   */
  compileModel(node) {
    this.emitLine(`export class ${node.name} {`);
    this.indent();

    // Generate constructor
    const constructorParams = node.properties
      .filter(p => !p.defaultValue)
      .map(p => p.name)
      .join(', ');

    this.emitLine(`constructor(${constructorParams}) {`);
    this.indent();

    for (const property of node.properties) {
      if (property.defaultValue) {
        const defaultValue = this.compileExpression(property.defaultValue);
        this.emitLine(`this.${property.name} = ${property.name} !== undefined ? ${property.name} : ${defaultValue};`);
      } else {
        this.emitLine(`this.${property.name} = ${property.name};`);
      }
    }

    this.dedent();
    this.emitLine('}');
    this.emitLine('');

    // Compile methods
    for (const method of node.methods) {
      this.compileMethod(method);
    }

    this.dedent();
    this.emitLine('}');
  }

  /**
   * Compile a service declaration
   */
  compileService(node) {
    this.emitLine(`export class ${node.name} {`);
    this.indent();

    // Services are typically singletons
    this.emitLine('static instance = null;');
    this.emitLine('');
    this.emitLine('static getInstance() {');
    this.indent();
    this.emitLine('if (!this.instance) {');
    this.indent();
    this.emitLine('this.instance = new this();');
    this.dedent();
    this.emitLine('}');
    this.emitLine('return this.instance;');
    this.dedent();
    this.emitLine('}');
    this.emitLine('');

    // Compile methods
    for (const method of node.methods) {
      this.compileMethod(method);
    }

    this.dedent();
    this.emitLine('}');
  }

  /**
   * Compile a statement
   */
  compileStatement(node) {
    if (!node) return;

    switch (node.type) {
      case 'Block':
        return this.compileBlockStatement(node);
      case 'ExpressionStatement':
        this.emitLine(this.compileExpression(node.expression) + ';');
        break;
      case 'If':
        return this.compileIfStatement(node);
      case 'For':
        return this.compileForStatement(node);
      case 'While':
        return this.compileWhileStatement(node);
      case 'Return':
        return this.compileReturnStatement(node);
      case 'Break':
        this.emitLine('break;');
        break;
      case 'Continue':
        this.emitLine('continue;');
        break;
      case 'VariableDeclaration':
        return this.compileVariableDeclaration(node);
      default:
        throw new CompilerError(`Unknown statement type: ${node.type}`, node);
    }
  }

  /**
   * Compile block statement
   */
  compileBlockStatement(node) {
    this.emitLine('{');
    this.indent();

    for (const statement of node.statements) {
      this.compileStatement(statement);
    }

    this.dedent();
    this.emitLine('}');
  }

  /**
   * Compile if statement
   */
  compileIfStatement(node) {
    const condition = this.compileExpression(node.condition);
    this.emitLine(`if (${condition}) {`);
    this.indent();
    this.compileStatement(node.thenStatement);
    this.dedent();

    if (node.elseStatement) {
      this.emitLine('} else {');
      this.indent();
      this.compileStatement(node.elseStatement);
      this.dedent();
    }

    this.emitLine('}');
  }

  /**
   * Compile for statement
   */
  compileForStatement(node) {
    if (node.update === null && node.condition && node.condition.type) {
      // This is a for-in/for-of loop
      let variable;
      if (node.init && node.init.type === 'VariableDeclaration') {
        // Extract variable name from declaration
        variable = node.init.declarations[0].id.name;
      } else if (node.init && node.init.type === 'Identifier') {
        variable = node.init.name;
      } else {
        variable = 'item';
      }
      const iterable = this.compileExpression(node.condition);
      this.emitLine(`for (const ${variable} of ${iterable}) {`);
    } else {
      // Regular for loop
      const init = node.init ? this.compileStatement(node.init) : '';
      const condition = node.condition ? this.compileExpression(node.condition) : '';
      const update = node.update ? this.compileExpression(node.update) : '';
      this.emitLine(`for (${init}; ${condition}; ${update}) {`);
    }

    this.indent();
    this.compileStatement(node.body);
    this.dedent();
    this.emitLine('}');
  }

  /**
   * Compile while statement
   */
  compileWhileStatement(node) {
    const condition = this.compileExpression(node.condition);
    this.emitLine(`while (${condition}) {`);
    this.indent();
    this.compileStatement(node.body);
    this.dedent();
    this.emitLine('}');
  }

  /**
   * Compile return statement
   */
  compileReturnStatement(node) {
    if (node.expression) {
      const expr = this.compileExpression(node.expression);
      this.emitLine(`return ${expr};`);
    } else {
      this.emitLine('return;');
    }
  }

  /**
   * Compile variable declaration
   */
  compileVariableDeclaration(node) {
    for (const declarator of node.declarations) {
      const init = declarator.init ? ' = ' + this.compileExpression(declarator.init) : '';
      this.emitLine(`${node.kind} ${declarator.id.name}${init};`);
    }
  }

  /**
   * Compile an expression
   */
  compileExpression(node) {
    if (!node) return '';

    // Handle undefined or null nodes gracefully
    if (!node.type) {
      console.warn('Warning: Expression node missing type:', node);
      return '';
    }

    switch (node.type) {
      case 'BinaryExpression':
        return this.compileBinaryExpression(node);
      case 'UnaryExpression':
        return this.compileUnaryExpression(node);
      case 'Assignment':
        return this.compileAssignmentExpression(node);
      case 'Conditional':
        return this.compileConditionalExpression(node);
      case 'Call':
        return this.compileCallExpression(node);
      case 'Member':
        return this.compileMemberExpression(node);
      case 'Identifier':
        return node.name;
      case 'This':
        return 'this';
      case 'StringLiteral':
        return `"${node.value.replace(/"/g, '\\"')}"`;
      case 'NumberLiteral':
        return node.value.toString();
      case 'BooleanLiteral':
        return node.value.toString();
      case 'NullLiteral':
        return 'null';
      case 'ArrayLiteral':
        return this.compileArrayLiteral(node);
      case 'ObjectLiteral':
        return this.compileObjectLiteral(node);
      case 'JSXElement':
        return this.compileJSXElement(node);
      case 'JSXExpression':
        return this.compileExpression(node.expression);
      case 'ArrowFunction':
        return this.compileArrowFunction(node);
      case 'NewExpression':
        return this.compileNewExpression(node);
      default:
        throw new CompilerError(`Unknown expression type: ${node.type}`, node);
    }
  }

  /**
   * Compile binary expression
   */
  compileBinaryExpression(node) {
    const left = this.compileExpression(node.left);
    const right = this.compileExpression(node.right);
    const operator = node.operator.value;
    return `${left} ${operator} ${right}`;
  }

  /**
   * Compile unary expression
   */
  compileUnaryExpression(node) {
    const operand = this.compileExpression(node.operand);
    const operator = node.operator.value;

    if (node.isPrefix) {
      return `${operator}${operand}`;
    } else {
      return `${operand}${operator}`;
    }
  }

  /**
   * Compile assignment expression
   */
  compileAssignmentExpression(node) {
    const left = this.compileExpression(node.left);
    const right = this.compileExpression(node.right);
    const operator = node.operator.value;
    return `${left} ${operator} ${right}`;
  }

  /**
   * Compile conditional expression
   */
  compileConditionalExpression(node) {
    const condition = this.compileExpression(node.condition);
    const trueExpr = this.compileExpression(node.trueExpression);
    const falseExpr = this.compileExpression(node.falseExpression);
    return `${condition} ? ${trueExpr} : ${falseExpr}`;
  }

  /**
   * Compile call expression
   */
  compileCallExpression(node) {
    const callee = this.compileExpression(node.callee);
    const args = node.arguments.map(arg => this.compileExpression(arg)).join(', ');
    return `${callee}(${args})`;
  }

  /**
   * Compile member expression
   */
  compileMemberExpression(node) {
    const object = this.compileExpression(node.object);

    if (node.computed) {
      const property = this.compileExpression(node.property);
      return `${object}[${property}]`;
    } else {
      const property = node.property.name || this.compileExpression(node.property);
      return `${object}.${property}`;
    }
  }

  /**
   * Compile array literal
   */
  compileArrayLiteral(node) {
    const elements = node.elements.map(element => this.compileExpression(element)).join(', ');
    return `[${elements}]`;
  }

  /**
   * Compile object literal
   */
  compileObjectLiteral(node) {
    const properties = node.properties.map(prop => {
      let key;
      if (typeof prop.key === 'string') {
        key = prop.key;
      } else if (prop.key && prop.key.type === 'Identifier') {
        key = prop.key.name;
      } else if (prop.key && prop.key.name) {
        key = prop.key.name;
      } else {
        key = this.compileExpression(prop.key);
      }
      const value = this.compileExpression(prop.value);
      return `${key}: ${value}`;
    }).join(', ');
    return `{ ${properties} }`;
  }

  /**
   * Compile arrow function
   */
  compileArrowFunction(node) {
    const params = node.params.map(param => param.name).join(', ');

    if (node.body.type === 'Block') {
      const body = this.compileBlockStatement(node.body);
      return `(${params}) => ${body}`;
    } else {
      const body = this.compileExpression(node.body);
      return `(${params}) => ${body}`;
    }
  }

  /**
   * Compile new expression
   */
  compileNewExpression(node) {
    const callee = this.compileExpression(node.callee);
    const args = node.arguments.map(arg => this.compileExpression(arg)).join(', ');
    return `new ${callee}(${args})`;
  }

  /**
   * Compile JSX element to virtual DOM calls
   */
  compileJSXElement(node) {
    const tagName = `"${node.tagName}"`;

    // Compile attributes to props object
    let props = '{}';
    if (node.attributes.length > 0) {
      const propEntries = node.attributes.map(attr => {
        const name = attr.name;
        let value;

        if (attr.value === null) {
          // Boolean attribute like <input disabled />
          value = 'true';
        } else if (attr.value.type === 'StringLiteral') {
          value = `"${attr.value.value}"`;
        } else if (attr.value.type === 'JSXExpression') {
          value = this.compileExpression(attr.value.expression);
        } else {
          value = this.compileExpression(attr.value);
        }

        return `${name}: ${value}`;
      });
      props = `{ ${propEntries.join(', ')} }`;
    }

    // Compile children
    const children = node.children.map(child => {
      if (child.type === 'JSXText') {
        // Trim whitespace and escape quotes
        const text = child.value.trim();
        return text ? `"${text.replace(/"/g, '\\"')}"` : null;
      } else if (child.type === 'JSXElement') {
        return this.compileJSXElement(child);
      } else if (child.type === 'JSXExpression') {
        return this.compileExpression(child.expression);
      } else {
        return this.compileExpression(child);
      }
    }).filter(child => child !== null);

    const childrenArray = children.length > 0 ? `[${children.join(', ')}]` : '[]';

    // Generate virtual DOM creation call
    return `this.createElement(${tagName}, ${props}, ${childrenArray})`;
  }

  /**
   * Emit code with proper indentation
   */
  emit(code) {
    this.output[this.output.length - 1] = (this.output[this.output.length - 1] || '') + code;
    this.currentColumn += code.length;
  }

  /**
   * Emit a line of code with proper indentation
   */
  emitLine(code = '') {
    const indentation = '  '.repeat(this.indentLevel);
    this.output.push(indentation + code);
    this.currentLine++;
    this.currentColumn = indentation.length + code.length + 1;
  }

  /**
   * Increase indentation level
   */
  indent() {
    this.indentLevel++;
  }

  /**
   * Decrease indentation level
   */
  dedent() {
    if (this.indentLevel > 0) {
      this.indentLevel--;
    }
  }

  /**
   * Add source mapping
   */
  addSourceMapping(node) {
    if (this.options.generateSourceMaps && node && node.location) {
      this.sourceMap.addMapping(
        this.currentLine,
        this.currentColumn,
        node.location.line,
        node.location.column
      );
    }
  }

  /**
   * Get current location for source mapping
   */
  getLocation() {
    return {
      line: this.currentLine,
      column: this.currentColumn
    };
  }
}

// Utility functions for compiler
export const CompilerUtils = {
  /**
   * Escape JavaScript string
   */
  escapeString(str) {
    return str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/'/g, "\\'")
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\t/g, '\\t');
  },

  /**
   * Generate unique identifier
   */
  generateId(prefix = 'id') {
    return `${prefix}_${Math.random().toString(36).substr(2, 9)}`;
  },

  /**
   * Check if identifier is valid JavaScript
   */
  isValidIdentifier(name) {
    return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name);
  },

  /**
   * Convert TodoLang type to JavaScript type annotation (for documentation)
   */
  typeToComment(typeNode) {
    if (!typeNode) return '';

    let type = typeNode.name;
    if (typeNode.isArray) type += '[]';
    if (typeNode.isOptional) type += '?';

    return `/** @type {${type}} */`;
  }
};