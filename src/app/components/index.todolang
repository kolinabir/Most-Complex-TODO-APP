// TodoLang Application Components
// UI components for the todo application

// TodoInput component for adding new todos
component TodoInput {
  state {
    inputValue: string = ""
    isValid: boolean = true
    errorMessage: string = ""
    isSubmitting: boolean = false
  }

  render() {
    <div class="todo-input-container">
      <form class="todo-input-form" onSubmit={this.handleSubmit}>
        <input
          type="text"
          class={this.getInputClass()}
          placeholder="What needs to be done?"
          value={this.state.inputValue}
          onInput={this.handleInput}
          onKeyDown={this.handleKeyDown}
          disabled={this.state.isSubmitting}
          autoFocus={true}
        />
        <button
          type="submit"
          class="todo-input-submit"
          disabled={this.state.isSubmitting || this.state.inputValue.trim().length == 0}
        >
          Add
        </button>
      </form>
      {this.renderErrorMessage()}
    </div>
  }

  computed getInputClass() {
    let classes = "todo-input"
    if (this.state.isValid == false) {
      classes = classes + " todo-input-error"
    }
    if (this.state.isSubmitting) {
      classes = classes + " todo-input-submitting"
    }
    return classes
  }

  renderErrorMessage() {
    if (this.state.isValid == false && this.state.errorMessage.length > 0) {
      return <div class="todo-input-error-message">{this.state.errorMessage}</div>
    }
    return null
  }

  handleInput(event) {
    const value = event.target.value
    this.setState({
      inputValue: value,
      isValid: true,
      errorMessage: ""
    })
  }

  handleKeyDown(event) {
    if (event.key == "Enter") {
      event.preventDefault()
      this.submitTodo()
    }
  }

  handleSubmit(event) {
    event.preventDefault()
    this.submitTodo()
  }

  submitTodo() {
    if (this.state.isSubmitting) {
      return
    }

    const trimmedValue = this.state.inputValue.trim()

    // Validate input
    const validation = this.validateInput(trimmedValue)
    if (validation.isValid == false) {
      this.setState({
        isValid: false,
        errorMessage: validation.error
      })
      return
    }

    // Set submitting state
    this.setState({
      isSubmitting: true,
      isValid: true,
      errorMessage: ""
    })

    try {
      // Call parent callback if provided
      if (this.props.onAdd && typeof this.props.onAdd == "function") {
        this.props.onAdd(trimmedValue)
      }

      // Clear input on successful submission
      this.clearInput()
    } catch (error) {
      this.setState({
        isValid: false,
        errorMessage: "Failed to add todo. Please try again."
      })
    } finally {
      this.setState({
        isSubmitting: false
      })
    }
  }

  validateInput(text) {
    const result = {
      isValid: false,
      error: ""
    }

    if (text == null || text.length == 0) {
      result.error = "Todo text cannot be empty"
      return result
    }

    if (text.length > 500) {
      result.error = "Todo text cannot exceed 500 characters"
      return result
    }

    // Check for only whitespace
    if (text.replace(/\s/g, "").length == 0) {
      result.error = "Todo text cannot be only whitespace"
      return result
    }

    result.isValid = true
    return result
  }

  clearInput() {
    this.setState({
      inputValue: "",
      isValid: true,
      errorMessage: "",
      isSubmitting: false
    })
  }

  focus() {
    // Method to programmatically focus the input
    if (this._domNode) {
      const input = this._domNode.querySelector(".todo-input")
      if (input) {
        input.focus()
      }
    }
  }

  getValue() {
    return this.state.inputValue
  }

  setValue(value) {
    this.setState({
      inputValue: value || "",
      isValid: true,
      errorMessage: ""
    })
  }

  reset() {
    this.clearInput()
  }
}

// TodoItem component for individual todo items
component TodoItem {
  state {
    isEditing: boolean = false
    editValue: string = ""
    showDeleteConfirm: boolean = false
    isDeleting: boolean = false
    isToggling: boolean = false
    isUpdating: boolean = false
    editError: string = ""
  }

  render() {
    <div class={this.getItemClass()}>
      {this.renderDeleteConfirmDialog()}
      <div class="todo-item-content">
        <div class="todo-item-main">
          {this.renderToggleButton()}
          {this.renderContent()}
        </div>
        {this.renderActions()}
      </div>
    </div>
  }

  computed getItemClass() {
    let classes = "todo-item"
    if (this.props.todo && this.props.todo.completed) {
      classes = classes + " todo-item-completed"
    }
    if (this.state.isEditing) {
      classes = classes + " todo-item-editing"
    }
    if (this.state.isDeleting) {
      classes = classes + " todo-item-deleting"
    }
    return classes
  }

  renderToggleButton() {
    return (
      <button
        class="todo-item-toggle"
        onClick={this.handleToggle}
        disabled={this.state.isToggling || this.state.isDeleting}
        title={this.props.todo && this.props.todo.completed ? "Mark as incomplete" : "Mark as complete"}
      >
        <input
          type="checkbox"
          checked={this.props.todo && this.props.todo.completed}
          disabled={true}
          tabIndex={-1}
        />
        <span class="todo-item-toggle-indicator"></span>
      </button>
    )
  }

  renderContent() {
    if (this.state.isEditing) {
      return this.renderEditMode()
    }
    return this.renderViewMode()
  }

  renderViewMode() {
    return (
      <div class="todo-item-view">
        <span
          class="todo-item-text"
          onDoubleClick={this.handleStartEdit}
          title="Double-click to edit"
        >
          {this.props.todo ? this.props.todo.text : ""}
        </span>
        {this.renderTimestamp()}
      </div>
    )
  }

  renderEditMode() {
    return (
      <div class="todo-item-edit">
        <input
          type="text"
          class={this.getEditInputClass()}
          value={this.state.editValue}
          onInput={this.handleEditInput}
          onKeyDown={this.handleEditKeyDown}
          onBlur={this.handleEditBlur}
          autoFocus={true}
          disabled={this.state.isUpdating}
        />
        {this.renderEditError()}
        <div class="todo-item-edit-actions">
          <button
            class="todo-item-edit-save"
            onClick={this.handleSaveEdit}
            disabled={this.state.isUpdating || this.state.editValue.trim().length == 0}
          >
            Save
          </button>
          <button
            class="todo-item-edit-cancel"
            onClick={this.handleCancelEdit}
            disabled={this.state.isUpdating}
          >
            Cancel
          </button>
        </div>
      </div>
    )
  }

  computed getEditInputClass() {
    let classes = "todo-item-edit-input"
    if (this.state.editError.length > 0) {
      classes = classes + " todo-item-edit-input-error"
    }
    if (this.state.isUpdating) {
      classes = classes + " todo-item-edit-input-updating"
    }
    return classes
  }

  renderEditError() {
    if (this.state.editError.length > 0) {
      return <div class="todo-item-edit-error">{this.state.editError}</div>
    }
    return null
  }

  renderTimestamp() {
    if (this.props.todo && this.props.todo.createdAt) {
      const date = new Date(this.props.todo.createdAt)
      const formatted = this.formatDate(date)
      return <span class="todo-item-timestamp" title={date.toString()}>{formatted}</span>
    }
    return null
  }

  renderActions() {
    if (this.state.isEditing) {
      return null
    }

    return (
      <div class="todo-item-actions">
        <button
          class="todo-item-edit-btn"
          onClick={this.handleStartEdit}
          disabled={this.state.isDeleting || this.state.isToggling}
          title="Edit todo"
        >
          Edit
        </button>
        <button
          class="todo-item-delete-btn"
          onClick={this.handleStartDelete}
          disabled={this.state.isDeleting || this.state.isToggling}
          title="Delete todo"
        >
          Delete
        </button>
      </div>
    )
  }

  renderDeleteConfirmDialog() {
    if (this.state.showDeleteConfirm == false) {
      return null
    }

    return (
      <div class="todo-item-delete-confirm-overlay">
        <div class="todo-item-delete-confirm-dialog">
          <div class="todo-item-delete-confirm-content">
            <h3>Confirm Delete</h3>
            <p>Are you sure you want to delete this todo?</p>
            <p class="todo-item-delete-confirm-text">"{this.props.todo ? this.props.todo.text : ""}"</p>
          </div>
          <div class="todo-item-delete-confirm-actions">
            <button
              class="todo-item-delete-confirm-yes"
              onClick={this.handleConfirmDelete}
              disabled={this.state.isDeleting}
            >
              {this.state.isDeleting ? "Deleting..." : "Yes, Delete"}
            </button>
            <button
              class="todo-item-delete-confirm-no"
              onClick={this.handleCancelDelete}
              disabled={this.state.isDeleting}
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    )
  }

  // Event handlers
  handleToggle(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isToggling || this.state.isDeleting || this.state.isEditing) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({ isToggling: true })

    try {
      if (this.props.onToggle && typeof this.props.onToggle == "function") {
        this.props.onToggle(this.props.todo.id)
      }
    } catch (error) {
      console.error("Error toggling todo:", error)
    } finally {
      this.setState({ isToggling: false })
    }
  }

  handleStartEdit(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting || this.state.isToggling) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({
      isEditing: true,
      editValue: this.props.todo.text,
      editError: ""
    })
  }

  handleEditInput(event) {
    const value = event.target.value
    this.setState({
      editValue: value,
      editError: ""
    })
  }

  handleEditKeyDown(event) {
    if (event.key == "Enter") {
      event.preventDefault()
      this.handleSaveEdit()
    } else if (event.key == "Escape") {
      event.preventDefault()
      this.handleCancelEdit()
    }
  }

  handleEditBlur(event) {
    // Don't auto-save on blur to avoid conflicts with save/cancel buttons
    // User must explicitly save or cancel
  }

  handleSaveEdit(event) {
    if (event) {
      event.preventDefault()
      event.stopPropagation()
    }

    if (this.state.isUpdating) {
      return
    }

    const trimmedValue = this.state.editValue.trim()

    // Validate the edit
    const validation = this.validateEditText(trimmedValue)
    if (validation.isValid == false) {
      this.setState({
        editError: validation.error
      })
      return
    }

    // Check if text actually changed
    if (this.props.todo && trimmedValue == this.props.todo.text) {
      this.handleCancelEdit()
      return
    }

    this.setState({ isUpdating: true })

    try {
      if (this.props.onEdit && typeof this.props.onEdit == "function") {
        this.props.onEdit(this.props.todo.id, trimmedValue)
      }

      this.setState({
        isEditing: false,
        editValue: "",
        editError: "",
        isUpdating: false
      })
    } catch (error) {
      this.setState({
        editError: "Failed to update todo. Please try again.",
        isUpdating: false
      })
    }
  }

  handleCancelEdit(event) {
    if (event) {
      event.preventDefault()
      event.stopPropagation()
    }

    this.setState({
      isEditing: false,
      editValue: "",
      editError: "",
      isUpdating: false
    })
  }

  handleStartDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting || this.state.isToggling || this.state.isEditing) {
      return
    }

    this.setState({
      showDeleteConfirm: true
    })
  }

  handleConfirmDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({ isDeleting: true })

    try {
      if (this.props.onDelete && typeof this.props.onDelete == "function") {
        this.props.onDelete(this.props.todo.id)
      }

      this.setState({
        showDeleteConfirm: false,
        isDeleting: false
      })
    } catch (error) {
      console.error("Error deleting todo:", error)
      this.setState({
        isDeleting: false
      })
    }
  }

  handleCancelDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    this.setState({
      showDeleteConfirm: false
    })
  }

  // Utility methods
  validateEditText(text) {
    const result = {
      isValid: false,
      error: ""
    }

    if (text == null || text.length == 0) {
      result.error = "Todo text cannot be empty"
      return result
    }

    if (text.length > 500) {
      result.error = "Todo text cannot exceed 500 characters"
      return result
    }

    // Check for only whitespace
    if (text.replace(/\s/g, "").length == 0) {
      result.error = "Todo text cannot be only whitespace"
      return result
    }

    result.isValid = true
    return result
  }

  formatDate(date) {
    if (date == null) {
      return ""
    }

    const now = new Date()
    const diffMs = now.getTime() - date.getTime()
    const diffMinutes = Math.floor(diffMs / (1000 * 60))
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

    if (diffMinutes < 1) {
      return "just now"
    } else if (diffMinutes < 60) {
      return diffMinutes + " min ago"
    } else if (diffHours < 24) {
      return diffHours + " hour" + (diffHours == 1 ? "" : "s") + " ago"
    } else if (diffDays < 7) {
      return diffDays + " day" + (diffDays == 1 ? "" : "s") + " ago"
    } else {
      return date.toLocaleDateString()
    }
  }

  // Public methods for external control
  startEdit() {
    if (this.state.isDeleting || this.state.isToggling) {
      return false
    }

    if (this.props.todo == null) {
      return false
    }

    this.setState({
      isEditing: true,
      editValue: this.props.todo.text,
      editError: ""
    })
    return true
  }

  cancelEdit() {
    this.handleCancelEdit()
  }

  isInEditMode() {
    return this.state.isEditing
  }

  focus() {
    if (this.state.isEditing) {
      // Focus the edit input
      if (this._domNode) {
        const input = this._domNode.querySelector(".todo-item-edit-input")
        if (input) {
          input.focus()
        }
      }
    }
  }
}