// TodoLang Application Components
// UI components for the todo application

// TodoInput component for adding new todos
component TodoInput {
  state {
    inputValue: string = ""
    isValid: boolean = true
    errorMessage: string = ""
    isSubmitting: boolean = false
  }

  render() {
    <div class="todo-input-container">
      <form class="todo-input-form" onSubmit={this.handleSubmit}>
        <input
          type="text"
          class={this.getInputClass()}
          placeholder="What needs to be done?"
          value={this.state.inputValue}
          onInput={this.handleInput}
          onKeyDown={this.handleKeyDown}
          disabled={this.state.isSubmitting}
          autoFocus={true}
        />
        <button
          type="submit"
          class="todo-input-submit"
          disabled={this.state.isSubmitting || this.state.inputValue.trim().length == 0}
        >
          Add
        </button>
      </form>
      {this.renderErrorMessage()}
    </div>
  }

  computed getInputClass() {
    let classes = "todo-input"
    if (this.state.isValid == false) {
      classes = classes + " todo-input-error"
    }
    if (this.state.isSubmitting) {
      classes = classes + " todo-input-submitting"
    }
    return classes
  }

  renderErrorMessage() {
    if (this.state.isValid == false && this.state.errorMessage.length > 0) {
      return <div class="todo-input-error-message">{this.state.errorMessage}</div>
    }
    return null
  }

  handleInput(event) {
    const value = event.target.value
    this.setState({
      inputValue: value,
      isValid: true,
      errorMessage: ""
    })
  }

  handleKeyDown(event) {
    if (event.key == "Enter") {
      event.preventDefault()
      this.submitTodo()
    }
  }

  handleSubmit(event) {
    event.preventDefault()
    this.submitTodo()
  }

  submitTodo() {
    if (this.state.isSubmitting) {
      return
    }

    const trimmedValue = this.state.inputValue.trim()

    // Validate input
    const validation = this.validateInput(trimmedValue)
    if (validation.isValid == false) {
      this.setState({
        isValid: false,
        errorMessage: validation.error
      })
      return
    }

    // Set submitting state
    this.setState({
      isSubmitting: true,
      isValid: true,
      errorMessage: ""
    })

    try {
      // Call parent callback if provided
      if (this.props.onAdd && typeof this.props.onAdd == "function") {
        this.props.onAdd(trimmedValue)
      }

      // Clear input on successful submission
      this.clearInput()
    } catch (error) {
      this.setState({
        isValid: false,
        errorMessage: "Failed to add todo. Please try again."
      })
    } finally {
      this.setState({
        isSubmitting: false
      })
    }
  }

  validateInput(text) {
    const result = {
      isValid: false,
      error: ""
    }

    if (text == null || text.length == 0) {
      result.error = "Todo text cannot be empty"
      return result
    }

    if (text.length > 500) {
      result.error = "Todo text cannot exceed 500 characters"
      return result
    }

    // Check for only whitespace
    if (text.replace(/\s/g, "").length == 0) {
      result.error = "Todo text cannot be only whitespace"
      return result
    }

    result.isValid = true
    return result
  }

  clearInput() {
    this.setState({
      inputValue: "",
      isValid: true,
      errorMessage: "",
      isSubmitting: false
    })
  }

  focus() {
    // Method to programmatically focus the input
    if (this._domNode) {
      const input = this._domNode.querySelector(".todo-input")
      if (input) {
        input.focus()
      }
    }
  }

  getValue() {
    return this.state.inputValue
  }

  setValue(value) {
    this.setState({
      inputValue: value || "",
      isValid: true,
      errorMessage: ""
    })
  }

  reset() {
    this.clearInput()
  }
}

// TodoItem component for individual todo items
component TodoItem {
  state {
    isEditing: boolean = false
    editValue: string = ""
    showDeleteConfirm: boolean = false
    isDeleting: boolean = false
    isToggling: boolean = false
    isUpdating: boolean = false
    editError: string = ""
  }

  render() {
    <div class={this.getItemClass()}>
      {this.renderDeleteConfirmDialog()}
      <div class="todo-item-content">
        <div class="todo-item-main">
          {this.renderToggleButton()}
          {this.renderContent()}
        </div>
        {this.renderActions()}
      </div>
    </div>
  }

  computed getItemClass() {
    let classes = "todo-item"
    if (this.props.todo && this.props.todo.completed) {
      classes = classes + " todo-item-completed"
    }
    if (this.state.isEditing) {
      classes = classes + " todo-item-editing"
    }
    if (this.state.isDeleting) {
      classes = classes + " todo-item-deleting"
    }
    return classes
  }

  renderToggleButton() {
    return (
      <button
        class="todo-item-toggle"
        onClick={this.handleToggle}
        disabled={this.state.isToggling || this.state.isDeleting}
        title={this.props.todo && this.props.todo.completed ? "Mark as incomplete" : "Mark as complete"}
      >
        <input
          type="checkbox"
          checked={this.props.todo && this.props.todo.completed}
          disabled={true}
          tabIndex={-1}
        />
        <span class="todo-item-toggle-indicator"></span>
      </button>
    )
  }

  renderContent() {
    if (this.state.isEditing) {
      return this.renderEditMode()
    }
    return this.renderViewMode()
  }

  renderViewMode() {
    return (
      <div class="todo-item-view">
        <span
          class="todo-item-text"
          onDoubleClick={this.handleStartEdit}
          title="Double-click to edit"
        >
          {this.props.todo ? this.props.todo.text : ""}
        </span>
        {this.renderTimestamp()}
      </div>
    )
  }

  renderEditMode() {
    return (
      <div class="todo-item-edit">
        <input
          type="text"
          class={this.getEditInputClass()}
          value={this.state.editValue}
          onInput={this.handleEditInput}
          onKeyDown={this.handleEditKeyDown}
          onBlur={this.handleEditBlur}
          autoFocus={true}
          disabled={this.state.isUpdating}
        />
        {this.renderEditError()}
        <div class="todo-item-edit-actions">
          <button
            class="todo-item-edit-save"
            onClick={this.handleSaveEdit}
            disabled={this.state.isUpdating || this.state.editValue.trim().length == 0}
          >
            Save
          </button>
          <button
            class="todo-item-edit-cancel"
            onClick={this.handleCancelEdit}
            disabled={this.state.isUpdating}
          >
            Cancel
          </button>
        </div>
      </div>
    )
  }

  computed getEditInputClass() {
    let classes = "todo-item-edit-input"
    if (this.state.editError.length > 0) {
      classes = classes + " todo-item-edit-input-error"
    }
    if (this.state.isUpdating) {
      classes = classes + " todo-item-edit-input-updating"
    }
    return classes
  }

  renderEditError() {
    if (this.state.editError.length > 0) {
      return <div class="todo-item-edit-error">{this.state.editError}</div>
    }
    return null
  }

  renderTimestamp() {
    if (this.props.todo && this.props.todo.createdAt) {
      const date = new Date(this.props.todo.createdAt)
      const formatted = this.formatDate(date)
      return <span class="todo-item-timestamp" title={date.toString()}>{formatted}</span>
    }
    return null
  }

  renderActions() {
    if (this.state.isEditing) {
      return null
    }

    return (
      <div class="todo-item-actions">
        <button
          class="todo-item-edit-btn"
          onClick={this.handleStartEdit}
          disabled={this.state.isDeleting || this.state.isToggling}
          title="Edit todo"
        >
          Edit
        </button>
        <button
          class="todo-item-delete-btn"
          onClick={this.handleStartDelete}
          disabled={this.state.isDeleting || this.state.isToggling}
          title="Delete todo"
        >
          Delete
        </button>
      </div>
    )
  }

  renderDeleteConfirmDialog() {
    if (this.state.showDeleteConfirm == false) {
      return null
    }

    return (
      <div class="todo-item-delete-confirm-overlay">
        <div class="todo-item-delete-confirm-dialog">
          <div class="todo-item-delete-confirm-content">
            <h3>Confirm Delete</h3>
            <p>Are you sure you want to delete this todo?</p>
            <p class="todo-item-delete-confirm-text">"{this.props.todo ? this.props.todo.text : ""}"</p>
          </div>
          <div class="todo-item-delete-confirm-actions">
            <button
              class="todo-item-delete-confirm-yes"
              onClick={this.handleConfirmDelete}
              disabled={this.state.isDeleting}
            >
              {this.state.isDeleting ? "Deleting..." : "Yes, Delete"}
            </button>
            <button
              class="todo-item-delete-confirm-no"
              onClick={this.handleCancelDelete}
              disabled={this.state.isDeleting}
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    )
  }

  // Event handlers
  handleToggle(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isToggling || this.state.isDeleting || this.state.isEditing) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({ isToggling: true })

    try {
      if (this.props.onToggle && typeof this.props.onToggle == "function") {
        this.props.onToggle(this.props.todo.id)
      }
    } catch (error) {
      console.error("Error toggling todo:", error)
    } finally {
      this.setState({ isToggling: false })
    }
  }

  handleStartEdit(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting || this.state.isToggling) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({
      isEditing: true,
      editValue: this.props.todo.text,
      editError: ""
    })
  }

  handleEditInput(event) {
    const value = event.target.value
    this.setState({
      editValue: value,
      editError: ""
    })
  }

  handleEditKeyDown(event) {
    if (event.key == "Enter") {
      event.preventDefault()
      this.handleSaveEdit()
    } else if (event.key == "Escape") {
      event.preventDefault()
      this.handleCancelEdit()
    }
  }

  handleEditBlur(event) {
    // Don't auto-save on blur to avoid conflicts with save/cancel buttons
    // User must explicitly save or cancel
  }

  handleSaveEdit(event) {
    if (event) {
      event.preventDefault()
      event.stopPropagation()
    }

    if (this.state.isUpdating) {
      return
    }

    const trimmedValue = this.state.editValue.trim()

    // Validate the edit
    const validation = this.validateEditText(trimmedValue)
    if (validation.isValid == false) {
      this.setState({
        editError: validation.error
      })
      return
    }

    // Check if text actually changed
    if (this.props.todo && trimmedValue == this.props.todo.text) {
      this.handleCancelEdit()
      return
    }

    this.setState({ isUpdating: true })

    try {
      if (this.props.onEdit && typeof this.props.onEdit == "function") {
        this.props.onEdit(this.props.todo.id, trimmedValue)
      }

      this.setState({
        isEditing: false,
        editValue: "",
        editError: "",
        isUpdating: false
      })
    } catch (error) {
      this.setState({
        editError: "Failed to update todo. Please try again.",
        isUpdating: false
      })
    }
  }

  handleCancelEdit(event) {
    if (event) {
      event.preventDefault()
      event.stopPropagation()
    }

    this.setState({
      isEditing: false,
      editValue: "",
      editError: "",
      isUpdating: false
    })
  }

  handleStartDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting || this.state.isToggling || this.state.isEditing) {
      return
    }

    this.setState({
      showDeleteConfirm: true
    })
  }

  handleConfirmDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({ isDeleting: true })

    try {
      if (this.props.onDelete && typeof this.props.onDelete == "function") {
        this.props.onDelete(this.props.todo.id)
      }

      this.setState({
        showDeleteConfirm: false,
        isDeleting: false
      })
    } catch (error) {
      console.error("Error deleting todo:", error)
      this.setState({
        isDeleting: false
      })
    }
  }

  handleCancelDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    this.setState({
      showDeleteConfirm: false
    })
  }

  // Utility methods
  validateEditText(text) {
    const result = {
      isValid: false,
      error: ""
    }

    if (text == null || text.length == 0) {
      result.error = "Todo text cannot be empty"
      return result
    }

    if (text.length > 500) {
      result.error = "Todo text cannot exceed 500 characters"
      return result
    }

    // Check for only whitespace
    if (text.replace(/\s/g, "").length == 0) {
      result.error = "Todo text cannot be only whitespace"
      return result
    }

    result.isValid = true
    return result
  }

  formatDate(date) {
    if (date == null) {
      return ""
    }

    const now = new Date()
    const diffMs = now.getTime() - date.getTime()
    const diffMinutes = Math.floor(diffMs / (1000 * 60))
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

    if (diffMinutes < 1) {
      return "just now"
    } else if (diffMinutes < 60) {
      return diffMinutes + " min ago"
    } else if (diffHours < 24) {
      return diffHours + " hour" + (diffHours == 1 ? "" : "s") + " ago"
    } else if (diffDays < 7) {
      return diffDays + " day" + (diffDays == 1 ? "" : "s") + " ago"
    } else {
      return date.toLocaleDateString()
    }
  }

  // Public methods for external control
  startEdit() {
    if (this.state.isDeleting || this.state.isToggling) {
      return false
    }

    if (this.props.todo == null) {
      return false
    }

    this.setState({
      isEditing: true,
      editValue: this.props.todo.text,
      editError: ""
    })
    return true
  }

  cancelEdit() {
    this.handleCancelEdit()
  }

  isInEditMode() {
    return this.state.isEditing
  }

  focus() {
    if (this.state.isEditing) {
      // Focus the edit input
      if (this._domNode) {
        const input = this._domNode.querySelector(".todo-item-edit-input")
        if (input) {
          input.focus()
        }
      }
    }
  }
}

// TodoList component for displaying multiple todo items
component TodoList {
  state {
    isLoading: boolean = false
    error: string = ""
    selectedItems: string[] = []
    sortOrder: string = "created" // "created", "alphabetical", "completed"
    showCompleted: boolean = true
  }

  render() {
    <div class={this.getListClass()}>
      {this.renderContent()}
    </div>
  }

  computed getListClass() {
    let classes = "todo-list"
    if (this.state.isLoading) {
      classes = classes + " todo-list-loading"
    }
    if (this.state.error.length > 0) {
      classes = classes + " todo-list-error"
    }
    if (this.isEmpty()) {
      classes = classes + " todo-list-empty"
    }
    return classes
  }

  renderContent() {
    if (this.state.error.length > 0) {
      return this.renderError()
    }

    if (this.state.isLoading) {
      return this.renderLoading()
    }

    if (this.isEmpty()) {
      return this.renderEmptyState()
    }

    return this.renderTodoItems()
  }

  renderError() {
    return (
      <div class="todo-list-error-container">
        <div class="todo-list-error-icon">⚠️</div>
        <div class="todo-list-error-message">{this.state.error}</div>
        <button
          class="todo-list-error-retry"
          onClick={this.handleRetry}
        >
          Try Again
        </button>
      </div>
    )
  }

  renderLoading() {
    return (
      <div class="todo-list-loading-container">
        <div class="todo-list-loading-spinner"></div>
        <div class="todo-list-loading-text">Loading todos...</div>
      </div>
    )
  }

  renderEmptyState() {
    const filter = this.props.filter || "all"
    const emptyMessage = this.getEmptyMessage(filter)
    const emptyIcon = this.getEmptyIcon(filter)

    return (
      <div class="todo-list-empty-container">
        <div class="todo-list-empty-icon">{emptyIcon}</div>
        <div class="todo-list-empty-message">{emptyMessage}</div>
        {this.renderEmptyStateActions(filter)}
      </div>
    )
  }

  getEmptyMessage(filter) {
    if (filter == "active") {
      return "No active todos! You're all caught up."
    }
    if (filter == "completed") {
      return "No completed todos yet."
    }
    return "No todos yet. Add one above to get started!"
  }

  getEmptyIcon(filter) {
    if (filter == "active") {
      return "✅"
    }
    if (filter == "completed") {
      return "📝"
    }
    return "📋"
  }

  renderEmptyStateActions(filter) {
    if (filter == "active" && this.hasCompletedTodos()) {
      return (
        <div class="todo-list-empty-actions">
          <button
            class="todo-list-empty-action"
            onClick={this.handleShowAll}
          >
            View All Todos
          </button>
        </div>
      )
    }

    if (filter == "completed" && this.hasActiveTodos()) {
      return (
        <div class="todo-list-empty-actions">
          <button
            class="todo-list-empty-action"
            onClick={this.handleShowActive}
          >
            View Active Todos
          </button>
        </div>
      )
    }

    return null
  }

  renderTodoItems() {
    const todos = this.getFilteredAndSortedTodos()

    return (
      <div class="todo-list-items-container">
        {this.renderListHeader(todos)}
        <div class="todo-list-items">
          {todos.map(todo => this.renderTodoItem(todo))}
        </div>
        {this.renderListFooter(todos)}
      </div>
    )
  }

  renderListHeader(todos) {
    if (todos.length == 0) {
      return null
    }

    const totalCount = todos.length
    const completedCount = todos.filter(todo => todo.completed).length
    const activeCount = totalCount - completedCount

    return (
      <div class="todo-list-header">
        <div class="todo-list-stats">
          <span class="todo-list-stat">
            <span class="todo-list-stat-number">{totalCount}</span>
            <span class="todo-list-stat-label">total</span>
          </span>
          <span class="todo-list-stat">
            <span class="todo-list-stat-number">{activeCount}</span>
            <span class="todo-list-stat-label">active</span>
          </span>
          <span class="todo-list-stat">
            <span class="todo-list-stat-number">{completedCount}</span>
            <span class="todo-list-stat-label">completed</span>
          </span>
        </div>
        {this.renderSortControls()}
      </div>
    )
  }

  renderSortControls() {
    return (
      <div class="todo-list-sort-controls">
        <label class="todo-list-sort-label">Sort by:</label>
        <select
          class="todo-list-sort-select"
          value={this.state.sortOrder}
          onChange={this.handleSortChange}
        >
          <option value="created">Date Created</option>
          <option value="alphabetical">Alphabetical</option>
          <option value="completed">Completion Status</option>
        </select>
      </div>
    )
  }

  renderTodoItem(todo) {
    return (
      <TodoItem
        key={todo.id}
        todo={todo}
        onToggle={this.props.onToggle}
        onEdit={this.props.onEdit}
        onDelete={this.props.onDelete}
        isSelected={this.isItemSelected(todo.id)}
        onSelect={this.handleItemSelect}
      />
    )
  }

  renderListFooter(todos) {
    if (todos.length == 0) {
      return null
    }

    const hasCompleted = todos.some(todo => todo.completed)
    const hasSelected = this.state.selectedItems.length > 0

    return (
      <div class="todo-list-footer">
        {this.renderBulkActions(hasSelected)}
        {this.renderQuickActions(hasCompleted)}
      </div>
    )
  }

  renderBulkActions(hasSelected) {
    if (hasSelected == false) {
      return null
    }

    const selectedCount = this.state.selectedItems.length

    return (
      <div class="todo-list-bulk-actions">
        <span class="todo-list-bulk-count">
          {selectedCount} item{selectedCount == 1 ? "" : "s"} selected
        </span>
        <div class="todo-list-bulk-buttons">
          <button
            class="todo-list-bulk-complete"
            onClick={this.handleBulkComplete}
          >
            Complete All
          </button>
          <button
            class="todo-list-bulk-delete"
            onClick={this.handleBulkDelete}
          >
            Delete All
          </button>
          <button
            class="todo-list-bulk-clear"
            onClick={this.handleClearSelection}
          >
            Clear Selection
          </button>
        </div>
      </div>
    )
  }

  renderQuickActions(hasCompleted) {
    return (
      <div class="todo-list-quick-actions">
        {hasCompleted && (
          <button
            class="todo-list-quick-action todo-list-clear-completed"
            onClick={this.handleClearCompleted}
          >
            Clear Completed
          </button>
        )}
        <button
          class="todo-list-quick-action todo-list-select-all"
          onClick={this.handleSelectAll}
        >
          Select All
        </button>
      </div>
    )
  }

  // Computed properties and utility methods
  isEmpty() {
    const todos = this.props.todos || []
    return todos.length == 0
  }

  hasActiveTodos() {
    const todos = this.props.todos || []
    return todos.some(todo => todo.completed == false)
  }

  hasCompletedTodos() {
    const todos = this.props.todos || []
    return todos.some(todo => todo.completed)
  }

  getFilteredAndSortedTodos() {
    let todos = this.props.todos || []

    // Apply filtering based on props.filter
    const filter = this.props.filter || "all"
    if (filter == "active") {
      todos = todos.filter(todo => todo.completed == false)
    } else if (filter == "completed") {
      todos = todos.filter(todo => todo.completed)
    }

    // Apply sorting
    todos = this.sortTodos(todos, this.state.sortOrder)

    return todos
  }

  sortTodos(todos, sortOrder) {
    const sorted = todos.slice() // Create a copy to avoid mutating props

    if (sortOrder == "alphabetical") {
      sorted.sort((a, b) => {
        const textA = a.text.toLowerCase()
        const textB = b.text.toLowerCase()
        if (textA < textB) return -1
        if (textA > textB) return 1
        return 0
      })
    } else if (sortOrder == "completed") {
      sorted.sort((a, b) => {
        // Incomplete todos first, then completed
        if (a.completed == b.completed) {
          // If same completion status, sort by creation date
          return new Date(b.createdAt) - new Date(a.createdAt)
        }
        return a.completed ? 1 : -1
      })
    } else {
      // Default: sort by creation date (newest first)
      sorted.sort((a, b) => {
        return new Date(b.createdAt) - new Date(a.createdAt)
      })
    }

    return sorted
  }

  isItemSelected(todoId) {
    return this.state.selectedItems.includes(todoId)
  }

  // Event handlers
  handleRetry(event) {
    event.preventDefault()
    this.setState({
      error: "",
      isLoading: true
    })

    // Simulate retry by calling parent refresh if available
    if (this.props.onRefresh && typeof this.props.onRefresh == "function") {
      try {
        this.props.onRefresh()
        this.setState({ isLoading: false })
      } catch (error) {
        this.setState({
          error: "Failed to refresh todos. Please try again.",
          isLoading: false
        })
      }
    } else {
      this.setState({ isLoading: false })
    }
  }

  handleShowAll(event) {
    event.preventDefault()
    if (this.props.onFilterChange && typeof this.props.onFilterChange == "function") {
      this.props.onFilterChange("all")
    }
  }

  handleShowActive(event) {
    event.preventDefault()
    if (this.props.onFilterChange && typeof this.props.onFilterChange == "function") {
      this.props.onFilterChange("active")
    }
  }

  handleSortChange(event) {
    const newSortOrder = event.target.value
    this.setState({ sortOrder: newSortOrder })

    // Notify parent of sort change if callback provided
    if (this.props.onSortChange && typeof this.props.onSortChange == "function") {
      this.props.onSortChange(newSortOrder)
    }
  }

  handleItemSelect(todoId, isSelected) {
    let selectedItems = this.state.selectedItems.slice()

    if (isSelected) {
      if (selectedItems.includes(todoId) == false) {
        selectedItems.push(todoId)
      }
    } else {
      selectedItems = selectedItems.filter(id => id != todoId)
    }

    this.setState({ selectedItems })

    // Notify parent of selection change
    if (this.props.onSelectionChange && typeof this.props.onSelectionChange == "function") {
      this.props.onSelectionChange(selectedItems)
    }
  }

  handleSelectAll(event) {
    event.preventDefault()
    const todos = this.getFilteredAndSortedTodos()
    const allIds = todos.map(todo => todo.id)
    this.setState({ selectedItems: allIds })

    if (this.props.onSelectionChange && typeof this.props.onSelectionChange == "function") {
      this.props.onSelectionChange(allIds)
    }
  }

  handleClearSelection(event) {
    event.preventDefault()
    this.setState({ selectedItems: [] })

    if (this.props.onSelectionChange && typeof this.props.onSelectionChange == "function") {
      this.props.onSelectionChange([])
    }
  }

  handleBulkComplete(event) {
    event.preventDefault()
    const selectedIds = this.state.selectedItems

    if (selectedIds.length == 0) {
      return
    }

    if (this.props.onBulkToggle && typeof this.props.onBulkToggle == "function") {
      this.props.onBulkToggle(selectedIds, true)
    }

    // Clear selection after bulk action
    this.setState({ selectedItems: [] })
  }

  handleBulkDelete(event) {
    event.preventDefault()
    const selectedIds = this.state.selectedItems

    if (selectedIds.length == 0) {
      return
    }

    // Show confirmation for bulk delete
    const confirmMessage = `Are you sure you want to delete ${selectedIds.length} todo${selectedIds.length == 1 ? "" : "s"}?`
    if (confirm(confirmMessage)) {
      if (this.props.onBulkDelete && typeof this.props.onBulkDelete == "function") {
        this.props.onBulkDelete(selectedIds)
      }

      // Clear selection after bulk action
      this.setState({ selectedItems: [] })
    }
  }

  handleClearCompleted(event) {
    event.preventDefault()
    if (this.props.onClearCompleted && typeof this.props.onClearCompleted == "function") {
      this.props.onClearCompleted()
    }
  }

  // Public methods for external control
  setLoading(isLoading) {
    this.setState({ isLoading: Boolean(isLoading) })
  }

  setError(error) {
    this.setState({
      error: error || "",
      isLoading: false
    })
  }

  clearError() {
    this.setState({ error: "" })
  }

  refresh() {
    this.handleRetry({ preventDefault: () => {} })
  }

  getSelectedItems() {
    return this.state.selectedItems.slice()
  }

  selectItem(todoId) {
    this.handleItemSelect(todoId, true)
  }

  deselectItem(todoId) {
    this.handleItemSelect(todoId, false)
  }

  selectAll() {
    this.handleSelectAll({ preventDefault: () => {} })
  }

  clearSelection() {
    this.handleClearSelection({ preventDefault: () => {} })
  }

  setSortOrder(sortOrder) {
    if (["created", "alphabetical", "completed"].includes(sortOrder)) {
      this.setState({ sortOrder })
    }
  }

  getSortOrder() {
    return this.state.sortOrder
  }

  getStats() {
    const todos = this.getFilteredAndSortedTodos()
    const total = todos.length
    const completed = todos.filter(todo => todo.completed).length
    const active = total - completed

    return {
      total,
      active,
      completed,
      selected: this.state.selectedItems.length
    }
  }
}

// TodoFilter component for filtering todos by completion status
component TodoFilter {
  state {
    currentFilter: string = "all"
    isChanging: boolean = false
    error: string = ""
    urlSyncEnabled: boolean = true
  }

  render() {
    <div class={this.getFilterClass()}>
      {this.renderFilterButtons()}
      {this.renderError()}
    </div>
  }

  computed getFilterClass() {
    let classes = "todo-filter"
    if (this.state.isChanging) {
      classes = classes + " todo-filter-changing"
    }
    if (this.state.error.length > 0) {
      classes = classes + " todo-filter-error"
    }
    return classes
  }

  renderFilterButtons() {
    const filters = this.getFilterOptions()

    return (
      <div class="todo-filter-buttons">
        <span class="todo-filter-label">Show:</span>
        <div class="todo-filter-button-group">
          {filters.map(filter => this.renderFilterButton(filter))}
        </div>
      </div>
    )
  }

  renderFilterButton(filter) {
    const isActive = this.isFilterActive(filter.value)
    const buttonClass = this.getButtonClass(filter.value, isActive)

    return (
      <button
        key={filter.value}
        class={buttonClass}
        onClick={() => this.handleFilterClick(filter.value)}
        disabled={this.state.isChanging}
        title={filter.description}
        aria-pressed={isActive}
      >
        <span class="todo-filter-button-text">{filter.label}</span>
        {this.renderFilterCount(filter.value)}
      </button>
    )
  }

  computed getButtonClass() {
    return (filterValue, isActive) => {
      let classes = "todo-filter-button"
      if (isActive) {
        classes = classes + " todo-filter-button-active"
      }
      if (this.state.isChanging) {
        classes = classes + " todo-filter-button-disabled"
      }
      classes = classes + " todo-filter-button-" + filterValue
      return classes
    }
  }

  renderFilterCount(filterValue) {
    if (this.props.showCounts == false) {
      return null
    }

    const count = this.getFilterCount(filterValue)
    if (count == null) {
      return null
    }

    return (
      <span class="todo-filter-button-count">
        ({count})
      </span>
    )
  }

  renderError() {
    if (this.state.error.length == 0) {
      return null
    }

    return (
      <div class="todo-filter-error">
        <span class="todo-filter-error-icon">⚠️</span>
        <span class="todo-filter-error-message">{this.state.error}</span>
        <button
          class="todo-filter-error-dismiss"
          onClick={this.handleDismissError}
          title="Dismiss error"
        >
          ×
        </button>
      </div>
    )
  }

  // Computed properties and utility methods
  getFilterOptions() {
    return [
      {
        value: "all",
        label: "All",
        description: "Show all todos"
      },
      {
        value: "active",
        label: "Active",
        description: "Show only incomplete todos"
      },
      {
        value: "completed",
        label: "Completed",
        description: "Show only completed todos"
      }
    ]
  }

  isFilterActive(filterValue) {
    const currentFilter = this.getCurrentFilter()
    return currentFilter == filterValue
  }

  getCurrentFilter() {
    // Priority: props.current > state.currentFilter > URL > default
    if (this.props.current) {
      return this.props.current
    }

    if (this.state.urlSyncEnabled) {
      const urlFilter = this.getFilterFromUrl()
      if (urlFilter) {
        return urlFilter
      }
    }

    return this.state.currentFilter
  }

  getFilterFromUrl() {
    if (typeof window == "undefined") {
      return null
    }

    try {
      const urlParams = new URLSearchParams(window.location.search)
      const filterParam = urlParams.get("filter")

      if (filterParam && this.isValidFilter(filterParam)) {
        return filterParam
      }

      // Also check hash-based routing
      const hash = window.location.hash
      if (hash.includes("filter=")) {
        const hashFilter = hash.split("filter=")[1]?.split("&")[0]
        if (hashFilter && this.isValidFilter(hashFilter)) {
          return hashFilter
        }
      }
    } catch (error) {
      console.warn("Error reading filter from URL:", error)
    }

    return null
  }

  isValidFilter(filterValue) {
    const validFilters = this.getFilterOptions().map(f => f.value)
    return validFilters.includes(filterValue)
  }

  getFilterCount(filterValue) {
    if (this.props.todos == null || this.props.todos.length == 0) {
      return 0
    }

    const todos = this.props.todos

    if (filterValue == "all") {
      return todos.length
    } else if (filterValue == "active") {
      return todos.filter(todo => todo.completed == false).length
    } else if (filterValue == "completed") {
      return todos.filter(todo => todo.completed).length
    }

    return null
  }

  // Event handlers
  handleFilterClick(filterValue) {
    if (this.state.isChanging) {
      return
    }

    if (this.isFilterActive(filterValue)) {
      return // Already active, no need to change
    }

    if (this.isValidFilter(filterValue) == false) {
      this.setState({
        error: `Invalid filter: ${filterValue}`
      })
      return
    }

    this.setState({
      isChanging: true,
      error: ""
    })

    try {
      // Update internal state
      this.setState({
        currentFilter: filterValue
      })

      // Update URL if enabled
      if (this.state.urlSyncEnabled) {
        this.updateUrl(filterValue)
      }

      // Call parent callback
      if (this.props.onChange && typeof this.props.onChange == "function") {
        this.props.onChange(filterValue)
      }

      // Persist filter state
      this.persistFilterState(filterValue)

    } catch (error) {
      console.error("Error changing filter:", error)
      this.setState({
        error: "Failed to change filter. Please try again."
      })
    } finally {
      this.setState({
        isChanging: false
      })
    }
  }

  handleDismissError(event) {
    event.preventDefault()
    event.stopPropagation()
    this.setState({ error: "" })
  }

  // URL management
  updateUrl(filterValue) {
    if (typeof window == "undefined") {
      return
    }

    try {
      const url = new URL(window.location)

      if (filterValue == "all") {
        // Remove filter parameter for "all" to keep URLs clean
        url.searchParams.delete("filter")
      } else {
        url.searchParams.set("filter", filterValue)
      }

      // Update URL without triggering page reload
      window.history.replaceState(
        { filter: filterValue },
        "",
        url.toString()
      )

      // Dispatch custom event for other components to listen
      window.dispatchEvent(new CustomEvent("filterChanged", {
        detail: { filter: filterValue, source: "url" }
      }))

    } catch (error) {
      console.warn("Error updating URL:", error)
    }
  }

  // Persistence
  persistFilterState(filterValue) {
    if (typeof localStorage == "undefined") {
      return
    }

    try {
      const filterState = {
        filter: filterValue,
        timestamp: Date.now()
      }

      localStorage.setItem("todoapp_filter_state", JSON.stringify(filterState))
    } catch (error) {
      console.warn("Error persisting filter state:", error)
    }
  }

  loadPersistedFilterState() {
    if (typeof localStorage == "undefined") {
      return null
    }

    try {
      const stored = localStorage.getItem("todoapp_filter_state")
      if (stored == null) {
        return null
      }

      const filterState = JSON.parse(stored)
      if (filterState && filterState.filter && this.isValidFilter(filterState.filter)) {
        return filterState.filter
      }
    } catch (error) {
      console.warn("Error loading persisted filter state:", error)
    }

    return null
  }

  clearPersistedFilterState() {
    if (typeof localStorage == "undefined") {
      return
    }

    try {
      localStorage.removeItem("todoapp_filter_state")
    } catch (error) {
      console.warn("Error clearing persisted filter state:", error)
    }
  }

  // Lifecycle methods
  componentDidMount() {
    // Initialize filter from URL or persisted state
    this.initializeFilter()

    // Listen for URL changes (browser back/forward)
    if (typeof window != "undefined" && this.state.urlSyncEnabled) {
      window.addEventListener("popstate", this.handleUrlChange)
      window.addEventListener("filterChanged", this.handleExternalFilterChange)
    }
  }

  componentWillUnmount() {
    // Clean up event listeners
    if (typeof window != "undefined") {
      window.removeEventListener("popstate", this.handleUrlChange)
      window.removeEventListener("filterChanged", this.handleExternalFilterChange)
    }
  }

  componentDidUpdate(prevProps) {
    // React to prop changes
    if (prevProps.current != this.props.current) {
      this.syncWithProps()
    }
  }

  initializeFilter() {
    let initialFilter = "all"

    // Priority: URL > persisted state > props > default
    const urlFilter = this.getFilterFromUrl()
    const persistedFilter = this.loadPersistedFilterState()

    if (urlFilter) {
      initialFilter = urlFilter
    } else if (persistedFilter) {
      initialFilter = persistedFilter
      // Update URL to match persisted state
      if (this.state.urlSyncEnabled) {
        this.updateUrl(initialFilter)
      }
    } else if (this.props.current && this.isValidFilter(this.props.current)) {
      initialFilter = this.props.current
    }

    this.setState({
      currentFilter: initialFilter
    })

    // Notify parent of initial filter
    if (this.props.onChange && typeof this.props.onChange == "function") {
      this.props.onChange(initialFilter)
    }
  }

  syncWithProps() {
    if (this.props.current && this.isValidFilter(this.props.current)) {
      const newFilter = this.props.current
      if (newFilter != this.state.currentFilter) {
        this.setState({
          currentFilter: newFilter
        })

        if (this.state.urlSyncEnabled) {
          this.updateUrl(newFilter)
        }

        this.persistFilterState(newFilter)
      }
    }
  }

  handleUrlChange = (event) => {
    const urlFilter = this.getFilterFromUrl()
    if (urlFilter && urlFilter != this.state.currentFilter) {
      this.setState({
        currentFilter: urlFilter
      })

      if (this.props.onChange && typeof this.props.onChange == "function") {
        this.props.onChange(urlFilter)
      }

      this.persistFilterState(urlFilter)
    }
  }

  handleExternalFilterChange = (event) => {
    // Handle filter changes from other sources
    if (event.detail && event.detail.filter && event.detail.source != "url") {
      const newFilter = event.detail.filter
      if (this.isValidFilter(newFilter) && newFilter != this.state.currentFilter) {
        this.setState({
          currentFilter: newFilter
        })
      }
    }
  }

  // Public methods for external control
  setFilter(filterValue) {
    if (this.isValidFilter(filterValue)) {
      this.handleFilterClick(filterValue)
      return true
    }
    return false
  }

  getFilter() {
    return this.getCurrentFilter()
  }

  resetFilter() {
    this.setFilter("all")
  }

  enableUrlSync() {
    this.setState({ urlSyncEnabled: true })
  }

  disableUrlSync() {
    this.setState({ urlSyncEnabled: false })
  }

  isUrlSyncEnabled() {
    return this.state.urlSyncEnabled
  }

  clearError() {
    this.setState({ error: "" })
  }

  getFilterStats() {
    const options = this.getFilterOptions()
    const stats = {}

    options.forEach(option => {
      stats[option.value] = {
        label: option.label,
        count: this.getFilterCount(option.value),
        active: this.isFilterActive(option.value)
      }
    })

    return stats
  }

  // Utility methods for testing and debugging
  getDebugInfo() {
    return {
      currentFilter: this.getCurrentFilter(),
      stateFilter: this.state.currentFilter,
      urlFilter: this.getFilterFromUrl(),
      persistedFilter: this.loadPersistedFilterState(),
      propsFilter: this.props.current,
      urlSyncEnabled: this.state.urlSyncEnabled,
      isChanging: this.state.isChanging,
      error: this.state.error
    }
  }
}

// Main TodoApp component - Root application component
component TodoApp {
  state {
    todos: Todo[] = []
    currentFilter: string = "all"
    isLoading: boolean = true
    error: string = ""
    isInitialized: boolean = false
    editingId: string? = null
    lastSavedAt: Date? = null
    autoSaveEnabled: boolean = true
  }

  render() {
    <div class={this.getAppClass()}>
      {this.renderHeader()}
      {this.renderContent()}
      {this.renderFooter()}
      {this.renderDebugInfo()}
    </div>
  }

  computed getAppClass() {
    let classes = "todo-app"
    if (this.state.isLoading) {
      classes = classes + " todo-app-loading"
    }
    if (this.state.error.length > 0) {
      classes = classes + " todo-app-error"
    }
    if (this.isEmpty()) {
      classes = classes + " todo-app-empty"
    }
    if (this.state.isInitialized == false) {
      classes = classes + " todo-app-initializing"
    }
    return classes
  }

  renderHeader() {
    return (
      <header class="todo-app-header">
        <h1 class="todo-app-title">TodoLang Application</h1>
        <p class="todo-app-subtitle">Built with custom language and framework</p>
        {this.renderStats()}
      </header>
    )
  }

  renderStats() {
    const stats = this.getTodoStats()

    return (
      <div class="todo-app-stats">
        <div class="todo-app-stat">
          <span class="todo-app-stat-number">{stats.total}</span>
          <span class="todo-app-stat-label">total</span>
        </div>
        <div class="todo-app-stat">
          <span class="todo-app-stat-number">{stats.active}</span>
          <span class="todo-app-stat-label">active</span>
        </div>
        <div class="todo-app-stat">
          <span class="todo-app-stat-number">{stats.completed}</span>
          <span class="todo-app-stat-label">completed</span>
        </div>
      </div>
    )
  }

  renderContent() {
    if (this.state.error.length > 0) {
      return this.renderError()
    }

    if (this.state.isLoading) {
      return this.renderLoading()
    }

    return (
      <main class="todo-app-main">
        {this.renderInput()}
        {this.renderFilter()}
        {this.renderList()}
      </main>
    )
  }

  renderError() {
    return (
      <div class="todo-app-error-container">
        <div class="todo-app-error-icon">⚠️</div>
        <h2 class="todo-app-error-title">Something went wrong</h2>
        <p class="todo-app-error-message">{this.state.error}</p>
        <div class="todo-app-error-actions">
          <button
            class="todo-app-error-retry"
            onClick={this.handleRetry}
          >
            Try Again
          </button>
          <button
            class="todo-app-error-reset"
            onClick={this.handleReset}
          >
            Reset Application
          </button>
        </div>
      </div>
    )
  }

  renderLoading() {
    return (
      <div class="todo-app-loading-container">
        <div class="todo-app-loading-spinner"></div>
        <p class="todo-app-loading-text">Loading your todos...</p>
      </div>
    )
  }

  renderInput() {
    return (
      <div class="todo-app-input-section">
        <TodoInput
          onAdd={this.handleAddTodo}
          disabled={this.state.isLoading}
          placeholder="What needs to be done?"
          autoFocus={true}
        />
      </div>
    )
  }

  renderFilter() {
    return (
      <div class="todo-app-filter-section">
        <TodoFilter
          current={this.state.currentFilter}
          onChange={this.handleFilterChange}
          todos={this.state.todos}
          showCounts={true}
        />
      </div>
    )
  }

  renderList() {
    const filteredTodos = this.getFilteredTodos()

    return (
      <div class="todo-app-list-section">
        <TodoList
          todos={filteredTodos}
          filter={this.state.currentFilter}
          onToggle={this.handleToggleTodo}
          onEdit={this.handleEditTodo}
          onDelete={this.handleDeleteTodo}
          onBulkToggle={this.handleBulkToggle}
          onBulkDelete={this.handleBulkDelete}
          onClearCompleted={this.handleClearCompleted}
          onRefresh={this.handleRefresh}
          onFilterChange={this.handleFilterChange}
          onSelectionChange={this.handleSelectionChange}
        />
      </div>
    )
  }

  renderFooter() {
    if (this.isEmpty()) {
      return null
    }

    return (
      <footer class="todo-app-footer">
        {this.renderQuickActions()}
        {this.renderSaveStatus()}
      </footer>
    )
  }

  renderQuickActions() {
    const hasCompleted = this.hasCompletedTodos()
    const hasActive = this.hasActiveTodos()

    return (
      <div class="todo-app-quick-actions">
        {hasActive && (
          <button
            class="todo-app-quick-action"
            onClick={this.handleCompleteAll}
            title="Mark all todos as complete"
          >
            Complete All
          </button>
        )}
        {hasCompleted && (
          <button
            class="todo-app-quick-action"
            onClick={this.handleClearCompleted}
            title="Remove all completed todos"
          >
            Clear Completed
          </button>
        )}
        <button
          class="todo-app-quick-action"
          onClick={this.handleClearAll}
          title="Remove all todos"
        >
          Clear All
        </button>
      </div>
    )
  }

  renderSaveStatus() {
    if (this.state.autoSaveEnabled == false) {
      return null
    }

    let statusText = ""
    let statusClass = "todo-app-save-status"

    if (this.state.lastSavedAt) {
      const timeSince = this.getTimeSinceLastSave()
      statusText = `Last saved ${timeSince}`
      statusClass = statusClass + " todo-app-save-status-saved"
    } else {
      statusText = "Not saved"
      statusClass = statusClass + " todo-app-save-status-unsaved"
    }

    return (
      <div class={statusClass}>
        <span class="todo-app-save-status-text">{statusText}</span>
        <button
          class="todo-app-save-status-manual"
          onClick={this.handleManualSave}
          title="Save now"
        >
          Save
        </button>
      </div>
    )
  }

  renderDebugInfo() {
    // Only show in development mode
    if (typeof window != "undefined" && window.location.hostname != "localhost") {
      return null
    }

    return (
      <details class="todo-app-debug">
        <summary>Debug Info</summary>
        <pre class="todo-app-debug-content">
          {JSON.stringify(this.getDebugInfo(), null, 2)}
        </pre>
      </details>
    )
  }

  // Computed properties
  computed getFilteredTodos() {
    return this.state.todos.filter(todo => {
      if (this.state.currentFilter == "active") {
        return todo.completed == false
      }
      if (this.state.currentFilter == "completed") {
        return todo.completed
      }
      return true // "all"
    })
  }

  getTodoStats() {
    const total = this.state.todos.length
    const completed = this.state.todos.filter(todo => todo.completed).length
    const active = total - completed

    return {
      total,
      active,
      completed,
      percentage: total > 0 ? Math.round((completed / total) * 100) : 0
    }
  }

  isEmpty() {
    return this.state.todos.length == 0
  }

  hasActiveTodos() {
    return this.state.todos.some(todo => todo.completed == false)
  }

  hasCompletedTodos() {
    return this.state.todos.some(todo => todo.completed)
  }

  getTimeSinceLastSave() {
    if (this.state.lastSavedAt == null) {
      return "never"
    }

    const now = Date.now()
    const diff = now - this.state.lastSavedAt.getTime()
    const seconds = Math.floor(diff / 1000)
    const minutes = Math.floor(seconds / 60)
    const hours = Math.floor(minutes / 60)

    if (seconds < 60) {
      return "just now"
    } else if (minutes < 60) {
      return `${minutes} minute${minutes == 1 ? "" : "s"} ago`
    } else if (hours < 24) {
      return `${hours} hour${hours == 1 ? "" : "s"} ago`
    } else {
      return this.state.lastSavedAt.toLocaleDateString()
    }
  }

  // CRUD Operations
  handleAddTodo(text) {
    if (text == null || text.trim().length == 0) {
      this.setError("Cannot add empty todo")
      return
    }

    try {
      const todo = Todo.create(text.trim())
      const newTodos = [...this.state.todos, todo]

      this.setState({
        todos: newTodos,
        error: ""
      })

      this.saveToStorage()
      this.logAction("ADD", { todoId: todo.id, text: todo.text })

    } catch (error) {
      console.error("Error adding todo:", error)
      this.setError("Failed to add todo: " + error.message)
    }
  }

  handleToggleTodo(todoId) {
    if (todoId == null) {
      return
    }

    try {
      const newTodos = this.state.todos.map(todo => {
        if (todo.id == todoId) {
          const updatedTodo = { ...todo }
          updatedTodo.completed = !updatedTodo.completed
          return updatedTodo
        }
        return todo
      })

      this.setState({
        todos: newTodos,
        error: ""
      })

      this.saveToStorage()
      this.logAction("TOGGLE", { todoId })

    } catch (error) {
      console.error("Error toggling todo:", error)
      this.setError("Failed to toggle todo")
    }
  }

  handleEditTodo(todoId, newText) {
    if (todoId == null || newText == null) {
      return
    }

    const trimmedText = newText.trim()
    if (trimmedText.length == 0) {
      this.setError("Todo text cannot be empty")
      return
    }

    try {
      const newTodos = this.state.todos.map(todo => {
        if (todo.id == todoId) {
          const updatedTodo = { ...todo }
          updatedTodo.text = trimmedText
          return updatedTodo
        }
        return todo
      })

      this.setState({
        todos: newTodos,
        editingId: null,
        error: ""
      })

      this.saveToStorage()
      this.logAction("EDIT", { todoId, newText: trimmedText })

    } catch (error) {
      console.error("Error editing todo:", error)
      this.setError("Failed to edit todo")
    }
  }

  handleDeleteTodo(todoId) {
    if (todoId == null) {
      return
    }

    try {
      const todoToDelete = this.state.todos.find(todo => todo.id == todoId)
      const newTodos = this.state.todos.filter(todo => todo.id != todoId)

      this.setState({
        todos: newTodos,
        error: ""
      })

      this.saveToStorage()
      this.logAction("DELETE", {
        todoId,
        text: todoToDelete ? todoToDelete.text : "unknown"
      })

    } catch (error) {
      console.error("Error deleting todo:", error)
      this.setError("Failed to delete todo")
    }
  }

  // Bulk operations
  handleBulkToggle(todoIds, completed) {
    if (todoIds == null || todoIds.length == 0) {
      return
    }

    try {
      const newTodos = this.state.todos.map(todo => {
        if (todoIds.includes(todo.id)) {
          const updatedTodo = { ...todo }
          updatedTodo.completed = Boolean(completed)
          return updatedTodo
        }
        return todo
      })

      this.setState({
        todos: newTodos,
        error: ""
      })

      this.saveToStorage()
      this.logAction("BULK_TOGGLE", { todoIds, completed })

    } catch (error) {
      console.error("Error bulk toggling todos:", error)
      this.setError("Failed to update todos")
    }
  }

  handleBulkDelete(todoIds) {
    if (todoIds == null || todoIds.length == 0) {
      return
    }

    try {
      const newTodos = this.state.todos.filter(todo => !todoIds.includes(todo.id))

      this.setState({
        todos: newTodos,
        error: ""
      })

      this.saveToStorage()
      this.logAction("BULK_DELETE", { todoIds, count: todoIds.length })

    } catch (error) {
      console.error("Error bulk deleting todos:", error)
      this.setError("Failed to delete todos")
    }
  }

  handleCompleteAll() {
    try {
      const newTodos = this.state.todos.map(todo => {
        const updatedTodo = { ...todo }
        updatedTodo.completed = true
        return updatedTodo
      })

      this.setState({
        todos: newTodos,
        error: ""
      })

      this.saveToStorage()
      this.logAction("COMPLETE_ALL", { count: this.state.todos.length })

    } catch (error) {
      console.error("Error completing all todos:", error)
      this.setError("Failed to complete all todos")
    }
  }

  handleClearCompleted() {
    try {
      const completedCount = this.state.todos.filter(todo => todo.completed).length
      const newTodos = this.state.todos.filter(todo => todo.completed == false)

      this.setState({
        todos: newTodos,
        error: ""
      })

      this.saveToStorage()
      this.logAction("CLEAR_COMPLETED", { count: completedCount })

    } catch (error) {
      console.error("Error clearing completed todos:", error)
      this.setError("Failed to clear completed todos")
    }
  }

  handleClearAll() {
    if (this.state.todos.length == 0) {
      return
    }

    const confirmMessage = `Are you sure you want to delete all ${this.state.todos.length} todos? This cannot be undone.`
    if (confirm(confirmMessage) == false) {
      return
    }

    try {
      const clearedCount = this.state.todos.length

      this.setState({
        todos: [],
        error: ""
      })

      this.saveToStorage()
      this.logAction("CLEAR_ALL", { count: clearedCount })

    } catch (error) {
      console.error("Error clearing all todos:", error)
      this.setError("Failed to clear all todos")
    }
  }

  // Filter handling
  handleFilterChange(newFilter) {
    if (newFilter == null || newFilter == this.state.currentFilter) {
      return
    }

    const validFilters = ["all", "active", "completed"]
    if (validFilters.includes(newFilter) == false) {
      this.setError("Invalid filter: " + newFilter)
      return
    }

    this.setState({
      currentFilter: newFilter,
      error: ""
    })

    this.logAction("FILTER_CHANGE", { filter: newFilter })
  }

  // Other event handlers
  handleSelectionChange(selectedIds) {
    // Handle selection changes from TodoList component
    // This could be used for bulk operations UI feedback
    this.logAction("SELECTION_CHANGE", { selectedIds })
  }

  handleRefresh() {
    this.loadFromStorage()
  }

  handleRetry() {
    this.setState({
      error: "",
      isLoading: true
    })

    this.initialize()
  }

  handleReset() {
    const confirmMessage = "Are you sure you want to reset the application? This will clear all data and cannot be undone."
    if (confirm(confirmMessage) == false) {
      return
    }

    try {
      this.clearStorage()
      this.setState({
        todos: [],
        currentFilter: "all",
        isLoading: false,
        error: "",
        isInitialized: true,
        editingId: null,
        lastSavedAt: null
      })

      this.logAction("RESET", {})

    } catch (error) {
      console.error("Error resetting application:", error)
      this.setError("Failed to reset application")
    }
  }

  handleManualSave() {
    this.saveToStorage()
  }

  // Storage operations
  saveToStorage() {
    if (this.state.autoSaveEnabled == false) {
      return
    }

    try {
      const dataToSave = {
        todos: this.state.todos.map(todo => todo.toData()),
        currentFilter: this.state.currentFilter,
        savedAt: Date.now(),
        version: "1.0"
      }

      const storageService = this.getStorageService()
      storageService.setItem("todoapp_data", dataToSave)

      this.setState({
        lastSavedAt: new Date(),
        error: ""
      })

    } catch (error) {
      console.error("Error saving to storage:", error)
      this.setError("Failed to save data: " + error.message)
    }
  }

  loadFromStorage() {
    try {
      const storageService = this.getStorageService()
      const savedData = storageService.getItem("todoapp_data")

      if (savedData == null) {
        // No saved data, start with empty state
        this.setState({
          todos: [],
          currentFilter: "all",
          isLoading: false,
          isInitialized: true,
          lastSavedAt: null
        })
        return
      }

      // Validate and restore saved data
      const todos = (savedData.todos || []).map(todoData => Todo.fromData(todoData))
      const currentFilter = savedData.currentFilter || "all"
      const lastSavedAt = savedData.savedAt ? new Date(savedData.savedAt) : null

      this.setState({
        todos,
        currentFilter,
        isLoading: false,
        isInitialized: true,
        lastSavedAt,
        error: ""
      })

      this.logAction("LOAD", { count: todos.length, filter: currentFilter })

    } catch (error) {
      console.error("Error loading from storage:", error)
      this.setError("Failed to load saved data: " + error.message)

      // Fall back to empty state
      this.setState({
        todos: [],
        currentFilter: "all",
        isLoading: false,
        isInitialized: true,
        lastSavedAt: null
      })
    }
  }

  clearStorage() {
    try {
      const storageService = this.getStorageService()
      storageService.removeItem("todoapp_data")
      storageService.removeItem("todoapp_filter_state")

      this.setState({
        lastSavedAt: null
      })

    } catch (error) {
      console.error("Error clearing storage:", error)
      throw error
    }
  }

  getStorageService() {
    // This would be injected via dependency injection in a real implementation
    // For now, we'll use a simple localStorage wrapper
    return {
      setItem: (key, value) => {
        localStorage.setItem(key, JSON.stringify(value))
      },
      getItem: (key) => {
        const item = localStorage.getItem(key)
        return item ? JSON.parse(item) : null
      },
      removeItem: (key) => {
        localStorage.removeItem(key)
      }
    }
  }

  // Lifecycle methods
  componentDidMount() {
    this.initialize()
  }

  componentWillUnmount() {
    // Save any pending changes
    if (this.state.autoSaveEnabled) {
      this.saveToStorage()
    }
  }

  initialize() {
    this.setState({
      isLoading: true,
      error: ""
    })

    try {
      // Load saved data
      this.loadFromStorage()

      // Set up auto-save interval
      if (this.state.autoSaveEnabled) {
        this.setupAutoSave()
      }

    } catch (error) {
      console.error("Error initializing application:", error)
      this.setError("Failed to initialize application: " + error.message)

      this.setState({
        isLoading: false,
        isInitialized: true
      })
    }
  }

  setupAutoSave() {
    // Auto-save every 30 seconds
    if (this._autoSaveInterval) {
      clearInterval(this._autoSaveInterval)
    }

    this._autoSaveInterval = setInterval(() => {
      if (this.state.autoSaveEnabled) {
        this.saveToStorage()
      }
    }, 30000)
  }

  // Utility methods
  setError(message) {
    this.setState({
      error: message || "",
      isLoading: false
    })
  }

  clearError() {
    this.setState({ error: "" })
  }

  logAction(action, data) {
    // Simple action logging for debugging
    if (typeof console != "undefined") {
      console.log(`[TodoApp] ${action}:`, data)
    }
  }

  getDebugInfo() {
    return {
      state: {
        todosCount: this.state.todos.length,
        currentFilter: this.state.currentFilter,
        isLoading: this.state.isLoading,
        error: this.state.error,
        isInitialized: this.state.isInitialized,
        editingId: this.state.editingId,
        lastSavedAt: this.state.lastSavedAt,
        autoSaveEnabled: this.state.autoSaveEnabled
      },
      computed: {
        filteredTodosCount: this.getFilteredTodos().length,
        stats: this.getTodoStats(),
        isEmpty: this.isEmpty(),
        hasActive: this.hasActiveTodos(),
        hasCompleted: this.hasCompletedTodos()
      },
      storage: {
        hasAutoSaveInterval: Boolean(this._autoSaveInterval)
      }
    }
  }

  // Public API methods for external control
  addTodo(text) {
    this.handleAddTodo(text)
  }

  toggleTodo(todoId) {
    this.handleToggleTodo(todoId)
  }

  editTodo(todoId, newText) {
    this.handleEditTodo(todoId, newText)
  }

  deleteTodo(todoId) {
    this.handleDeleteTodo(todoId)
  }

  setFilter(filter) {
    this.handleFilterChange(filter)
  }

  getFilter() {
    return this.state.currentFilter
  }

  getTodos() {
    return this.state.todos.slice()
  }

  getFilteredTodos() {
    return this.getFilteredTodos()
  }

  getStats() {
    return this.getTodoStats()
  }

  save() {
    this.saveToStorage()
  }

  load() {
    this.loadFromStorage()
  }

  reset() {
    this.handleReset()
  }

  enableAutoSave() {
    this.setState({ autoSaveEnabled: true })
    this.setupAutoSave()
  }

  disableAutoSave() {
    this.setState({ autoSaveEnabled: false })
    if (this._autoSaveInterval) {
      clearInterval(this._autoSaveInterval)
      this._autoSaveInterval = null
    }
  }

  isAutoSaveEnabled() {
    return this.state.autoSaveEnabled
  }
}