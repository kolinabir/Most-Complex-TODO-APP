// TodoLang Application Components
// UI components for the todo application

// TodoInput component for adding new todos
component TodoInput {
  state {
    inputValue: string = ""
    isValid: boolean = true
    errorMessage: string = ""
    isSubmitting: boolean = false
  }

  render() {
    <div class="todo-input-container">
      <form class="todo-input-form" onSubmit={this.handleSubmit}>
        <input
          type="text"
          class={this.getInputClass()}
          placeholder="What needs to be done?"
          value={this.state.inputValue}
          onInput={this.handleInput}
          onKeyDown={this.handleKeyDown}
          disabled={this.state.isSubmitting}
          autoFocus={true}
        />
        <button
          type="submit"
          class="todo-input-submit"
          disabled={this.state.isSubmitting || this.state.inputValue.trim().length == 0}
        >
          Add
        </button>
      </form>
      {this.renderErrorMessage()}
    </div>
  }

  computed getInputClass() {
    let classes = "todo-input"
    if (this.state.isValid == false) {
      classes = classes + " todo-input-error"
    }
    if (this.state.isSubmitting) {
      classes = classes + " todo-input-submitting"
    }
    return classes
  }

  renderErrorMessage() {
    if (this.state.isValid == false && this.state.errorMessage.length > 0) {
      return <div class="todo-input-error-message">{this.state.errorMessage}</div>
    }
    return null
  }

  handleInput(event) {
    const value = event.target.value
    this.setState({
      inputValue: value,
      isValid: true,
      errorMessage: ""
    })
  }

  handleKeyDown(event) {
    if (event.key == "Enter") {
      event.preventDefault()
      this.submitTodo()
    }
  }

  handleSubmit(event) {
    event.preventDefault()
    this.submitTodo()
  }

  submitTodo() {
    if (this.state.isSubmitting) {
      return
    }

    const trimmedValue = this.state.inputValue.trim()

    // Validate input
    const validation = this.validateInput(trimmedValue)
    if (validation.isValid == false) {
      this.setState({
        isValid: false,
        errorMessage: validation.error
      })
      return
    }

    // Set submitting state
    this.setState({
      isSubmitting: true,
      isValid: true,
      errorMessage: ""
    })

    try {
      // Call parent callback if provided
      if (this.props.onAdd && typeof this.props.onAdd == "function") {
        this.props.onAdd(trimmedValue)
      }

      // Clear input on successful submission
      this.clearInput()
    } catch (error) {
      this.setState({
        isValid: false,
        errorMessage: "Failed to add todo. Please try again."
      })
    } finally {
      this.setState({
        isSubmitting: false
      })
    }
  }

  validateInput(text) {
    const result = {
      isValid: false,
      error: ""
    }

    if (text == null || text.length == 0) {
      result.error = "Todo text cannot be empty"
      return result
    }

    if (text.length > 500) {
      result.error = "Todo text cannot exceed 500 characters"
      return result
    }

    // Check for only whitespace
    if (text.replace(/\s/g, "").length == 0) {
      result.error = "Todo text cannot be only whitespace"
      return result
    }

    result.isValid = true
    return result
  }

  clearInput() {
    this.setState({
      inputValue: "",
      isValid: true,
      errorMessage: "",
      isSubmitting: false
    })
  }

  focus() {
    // Method to programmatically focus the input
    if (this._domNode) {
      const input = this._domNode.querySelector(".todo-input")
      if (input) {
        input.focus()
      }
    }
  }

  getValue() {
    return this.state.inputValue
  }

  setValue(value) {
    this.setState({
      inputValue: value || "",
      isValid: true,
      errorMessage: ""
    })
  }

  reset() {
    this.clearInput()
  }
}

// TodoItem component for individual todo items
component TodoItem {
  state {
    isEditing: boolean = false
    editValue: string = ""
    showDeleteConfirm: boolean = false
    isDeleting: boolean = false
    isToggling: boolean = false
    isUpdating: boolean = false
    editError: string = ""
  }

  render() {
    <div class={this.getItemClass()}>
      {this.renderDeleteConfirmDialog()}
      <div class="todo-item-content">
        <div class="todo-item-main">
          {this.renderToggleButton()}
          {this.renderContent()}
        </div>
        {this.renderActions()}
      </div>
    </div>
  }

  computed getItemClass() {
    let classes = "todo-item"
    if (this.props.todo && this.props.todo.completed) {
      classes = classes + " todo-item-completed"
    }
    if (this.state.isEditing) {
      classes = classes + " todo-item-editing"
    }
    if (this.state.isDeleting) {
      classes = classes + " todo-item-deleting"
    }
    return classes
  }

  renderToggleButton() {
    return (
      <button
        class="todo-item-toggle"
        onClick={this.handleToggle}
        disabled={this.state.isToggling || this.state.isDeleting}
        title={this.props.todo && this.props.todo.completed ? "Mark as incomplete" : "Mark as complete"}
      >
        <input
          type="checkbox"
          checked={this.props.todo && this.props.todo.completed}
          disabled={true}
          tabIndex={-1}
        />
        <span class="todo-item-toggle-indicator"></span>
      </button>
    )
  }

  renderContent() {
    if (this.state.isEditing) {
      return this.renderEditMode()
    }
    return this.renderViewMode()
  }

  renderViewMode() {
    return (
      <div class="todo-item-view">
        <span
          class="todo-item-text"
          onDoubleClick={this.handleStartEdit}
          title="Double-click to edit"
        >
          {this.props.todo ? this.props.todo.text : ""}
        </span>
        {this.renderTimestamp()}
      </div>
    )
  }

  renderEditMode() {
    return (
      <div class="todo-item-edit">
        <input
          type="text"
          class={this.getEditInputClass()}
          value={this.state.editValue}
          onInput={this.handleEditInput}
          onKeyDown={this.handleEditKeyDown}
          onBlur={this.handleEditBlur}
          autoFocus={true}
          disabled={this.state.isUpdating}
        />
        {this.renderEditError()}
        <div class="todo-item-edit-actions">
          <button
            class="todo-item-edit-save"
            onClick={this.handleSaveEdit}
            disabled={this.state.isUpdating || this.state.editValue.trim().length == 0}
          >
            Save
          </button>
          <button
            class="todo-item-edit-cancel"
            onClick={this.handleCancelEdit}
            disabled={this.state.isUpdating}
          >
            Cancel
          </button>
        </div>
      </div>
    )
  }

  computed getEditInputClass() {
    let classes = "todo-item-edit-input"
    if (this.state.editError.length > 0) {
      classes = classes + " todo-item-edit-input-error"
    }
    if (this.state.isUpdating) {
      classes = classes + " todo-item-edit-input-updating"
    }
    return classes
  }

  renderEditError() {
    if (this.state.editError.length > 0) {
      return <div class="todo-item-edit-error">{this.state.editError}</div>
    }
    return null
  }

  renderTimestamp() {
    if (this.props.todo && this.props.todo.createdAt) {
      const date = new Date(this.props.todo.createdAt)
      const formatted = this.formatDate(date)
      return <span class="todo-item-timestamp" title={date.toString()}>{formatted}</span>
    }
    return null
  }

  renderActions() {
    if (this.state.isEditing) {
      return null
    }

    return (
      <div class="todo-item-actions">
        <button
          class="todo-item-edit-btn"
          onClick={this.handleStartEdit}
          disabled={this.state.isDeleting || this.state.isToggling}
          title="Edit todo"
        >
          Edit
        </button>
        <button
          class="todo-item-delete-btn"
          onClick={this.handleStartDelete}
          disabled={this.state.isDeleting || this.state.isToggling}
          title="Delete todo"
        >
          Delete
        </button>
      </div>
    )
  }

  renderDeleteConfirmDialog() {
    if (this.state.showDeleteConfirm == false) {
      return null
    }

    return (
      <div class="todo-item-delete-confirm-overlay">
        <div class="todo-item-delete-confirm-dialog">
          <div class="todo-item-delete-confirm-content">
            <h3>Confirm Delete</h3>
            <p>Are you sure you want to delete this todo?</p>
            <p class="todo-item-delete-confirm-text">"{this.props.todo ? this.props.todo.text : ""}"</p>
          </div>
          <div class="todo-item-delete-confirm-actions">
            <button
              class="todo-item-delete-confirm-yes"
              onClick={this.handleConfirmDelete}
              disabled={this.state.isDeleting}
            >
              {this.state.isDeleting ? "Deleting..." : "Yes, Delete"}
            </button>
            <button
              class="todo-item-delete-confirm-no"
              onClick={this.handleCancelDelete}
              disabled={this.state.isDeleting}
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    )
  }

  // Event handlers
  handleToggle(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isToggling || this.state.isDeleting || this.state.isEditing) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({ isToggling: true })

    try {
      if (this.props.onToggle && typeof this.props.onToggle == "function") {
        this.props.onToggle(this.props.todo.id)
      }
    } catch (error) {
      console.error("Error toggling todo:", error)
    } finally {
      this.setState({ isToggling: false })
    }
  }

  handleStartEdit(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting || this.state.isToggling) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({
      isEditing: true,
      editValue: this.props.todo.text,
      editError: ""
    })
  }

  handleEditInput(event) {
    const value = event.target.value
    this.setState({
      editValue: value,
      editError: ""
    })
  }

  handleEditKeyDown(event) {
    if (event.key == "Enter") {
      event.preventDefault()
      this.handleSaveEdit()
    } else if (event.key == "Escape") {
      event.preventDefault()
      this.handleCancelEdit()
    }
  }

  handleEditBlur(event) {
    // Don't auto-save on blur to avoid conflicts with save/cancel buttons
    // User must explicitly save or cancel
  }

  handleSaveEdit(event) {
    if (event) {
      event.preventDefault()
      event.stopPropagation()
    }

    if (this.state.isUpdating) {
      return
    }

    const trimmedValue = this.state.editValue.trim()

    // Validate the edit
    const validation = this.validateEditText(trimmedValue)
    if (validation.isValid == false) {
      this.setState({
        editError: validation.error
      })
      return
    }

    // Check if text actually changed
    if (this.props.todo && trimmedValue == this.props.todo.text) {
      this.handleCancelEdit()
      return
    }

    this.setState({ isUpdating: true })

    try {
      if (this.props.onEdit && typeof this.props.onEdit == "function") {
        this.props.onEdit(this.props.todo.id, trimmedValue)
      }

      this.setState({
        isEditing: false,
        editValue: "",
        editError: "",
        isUpdating: false
      })
    } catch (error) {
      this.setState({
        editError: "Failed to update todo. Please try again.",
        isUpdating: false
      })
    }
  }

  handleCancelEdit(event) {
    if (event) {
      event.preventDefault()
      event.stopPropagation()
    }

    this.setState({
      isEditing: false,
      editValue: "",
      editError: "",
      isUpdating: false
    })
  }

  handleStartDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting || this.state.isToggling || this.state.isEditing) {
      return
    }

    this.setState({
      showDeleteConfirm: true
    })
  }

  handleConfirmDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({ isDeleting: true })

    try {
      if (this.props.onDelete && typeof this.props.onDelete == "function") {
        this.props.onDelete(this.props.todo.id)
      }

      this.setState({
        showDeleteConfirm: false,
        isDeleting: false
      })
    } catch (error) {
      console.error("Error deleting todo:", error)
      this.setState({
        isDeleting: false
      })
    }
  }

  handleCancelDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    this.setState({
      showDeleteConfirm: false
    })
  }

  // Utility methods
  validateEditText(text) {
    const result = {
      isValid: false,
      error: ""
    }

    if (text == null || text.length == 0) {
      result.error = "Todo text cannot be empty"
      return result
    }

    if (text.length > 500) {
      result.error = "Todo text cannot exceed 500 characters"
      return result
    }

    // Check for only whitespace
    if (text.replace(/\s/g, "").length == 0) {
      result.error = "Todo text cannot be only whitespace"
      return result
    }

    result.isValid = true
    return result
  }

  formatDate(date) {
    if (date == null) {
      return ""
    }

    const now = new Date()
    const diffMs = now.getTime() - date.getTime()
    const diffMinutes = Math.floor(diffMs / (1000 * 60))
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

    if (diffMinutes < 1) {
      return "just now"
    } else if (diffMinutes < 60) {
      return diffMinutes + " min ago"
    } else if (diffHours < 24) {
      return diffHours + " hour" + (diffHours == 1 ? "" : "s") + " ago"
    } else if (diffDays < 7) {
      return diffDays + " day" + (diffDays == 1 ? "" : "s") + " ago"
    } else {
      return date.toLocaleDateString()
    }
  }

  // Public methods for external control
  startEdit() {
    if (this.state.isDeleting || this.state.isToggling) {
      return false
    }

    if (this.props.todo == null) {
      return false
    }

    this.setState({
      isEditing: true,
      editValue: this.props.todo.text,
      editError: ""
    })
    return true
  }

  cancelEdit() {
    this.handleCancelEdit()
  }

  isInEditMode() {
    return this.state.isEditing
  }

  focus() {
    if (this.state.isEditing) {
      // Focus the edit input
      if (this._domNode) {
        const input = this._domNode.querySelector(".todo-item-edit-input")
        if (input) {
          input.focus()
        }
      }
    }
  }
}

// TodoList component for displaying multiple todo items
component TodoList {
  state {
    isLoading: boolean = false
    error: string = ""
    selectedItems: string[] = []
    sortOrder: string = "created" // "created", "alphabetical", "completed"
    showCompleted: boolean = true
  }

  render() {
    <div class={this.getListClass()}>
      {this.renderContent()}
    </div>
  }

  computed getListClass() {
    let classes = "todo-list"
    if (this.state.isLoading) {
      classes = classes + " todo-list-loading"
    }
    if (this.state.error.length > 0) {
      classes = classes + " todo-list-error"
    }
    if (this.isEmpty()) {
      classes = classes + " todo-list-empty"
    }
    return classes
  }

  renderContent() {
    if (this.state.error.length > 0) {
      return this.renderError()
    }

    if (this.state.isLoading) {
      return this.renderLoading()
    }

    if (this.isEmpty()) {
      return this.renderEmptyState()
    }

    return this.renderTodoItems()
  }

  renderError() {
    return (
      <div class="todo-list-error-container">
        <div class="todo-list-error-icon">⚠️</div>
        <div class="todo-list-error-message">{this.state.error}</div>
        <button
          class="todo-list-error-retry"
          onClick={this.handleRetry}
        >
          Try Again
        </button>
      </div>
    )
  }

  renderLoading() {
    return (
      <div class="todo-list-loading-container">
        <div class="todo-list-loading-spinner"></div>
        <div class="todo-list-loading-text">Loading todos...</div>
      </div>
    )
  }

  renderEmptyState() {
    const filter = this.props.filter || "all"
    const emptyMessage = this.getEmptyMessage(filter)
    const emptyIcon = this.getEmptyIcon(filter)

    return (
      <div class="todo-list-empty-container">
        <div class="todo-list-empty-icon">{emptyIcon}</div>
        <div class="todo-list-empty-message">{emptyMessage}</div>
        {this.renderEmptyStateActions(filter)}
      </div>
    )
  }

  getEmptyMessage(filter) {
    if (filter == "active") {
      return "No active todos! You're all caught up."
    }
    if (filter == "completed") {
      return "No completed todos yet."
    }
    return "No todos yet. Add one above to get started!"
  }

  getEmptyIcon(filter) {
    if (filter == "active") {
      return "✅"
    }
    if (filter == "completed") {
      return "📝"
    }
    return "📋"
  }

  renderEmptyStateActions(filter) {
    if (filter == "active" && this.hasCompletedTodos()) {
      return (
        <div class="todo-list-empty-actions">
          <button
            class="todo-list-empty-action"
            onClick={this.handleShowAll}
          >
            View All Todos
          </button>
        </div>
      )
    }

    if (filter == "completed" && this.hasActiveTodos()) {
      return (
        <div class="todo-list-empty-actions">
          <button
            class="todo-list-empty-action"
            onClick={this.handleShowActive}
          >
            View Active Todos
          </button>
        </div>
      )
    }

    return null
  }

  renderTodoItems() {
    const todos = this.getFilteredAndSortedTodos()

    return (
      <div class="todo-list-items-container">
        {this.renderListHeader(todos)}
        <div class="todo-list-items">
          {todos.map(todo => this.renderTodoItem(todo))}
        </div>
        {this.renderListFooter(todos)}
      </div>
    )
  }

  renderListHeader(todos) {
    if (todos.length == 0) {
      return null
    }

    const totalCount = todos.length
    const completedCount = todos.filter(todo => todo.completed).length
    const activeCount = totalCount - completedCount

    return (
      <div class="todo-list-header">
        <div class="todo-list-stats">
          <span class="todo-list-stat">
            <span class="todo-list-stat-number">{totalCount}</span>
            <span class="todo-list-stat-label">total</span>
          </span>
          <span class="todo-list-stat">
            <span class="todo-list-stat-number">{activeCount}</span>
            <span class="todo-list-stat-label">active</span>
          </span>
          <span class="todo-list-stat">
            <span class="todo-list-stat-number">{completedCount}</span>
            <span class="todo-list-stat-label">completed</span>
          </span>
        </div>
        {this.renderSortControls()}
      </div>
    )
  }

  renderSortControls() {
    return (
      <div class="todo-list-sort-controls">
        <label class="todo-list-sort-label">Sort by:</label>
        <select
          class="todo-list-sort-select"
          value={this.state.sortOrder}
          onChange={this.handleSortChange}
        >
          <option value="created">Date Created</option>
          <option value="alphabetical">Alphabetical</option>
          <option value="completed">Completion Status</option>
        </select>
      </div>
    )
  }

  renderTodoItem(todo) {
    return (
      <TodoItem
        key={todo.id}
        todo={todo}
        onToggle={this.props.onToggle}
        onEdit={this.props.onEdit}
        onDelete={this.props.onDelete}
        isSelected={this.isItemSelected(todo.id)}
        onSelect={this.handleItemSelect}
      />
    )
  }

  renderListFooter(todos) {
    if (todos.length == 0) {
      return null
    }

    const hasCompleted = todos.some(todo => todo.completed)
    const hasSelected = this.state.selectedItems.length > 0

    return (
      <div class="todo-list-footer">
        {this.renderBulkActions(hasSelected)}
        {this.renderQuickActions(hasCompleted)}
      </div>
    )
  }

  renderBulkActions(hasSelected) {
    if (hasSelected == false) {
      return null
    }

    const selectedCount = this.state.selectedItems.length

    return (
      <div class="todo-list-bulk-actions">
        <span class="todo-list-bulk-count">
          {selectedCount} item{selectedCount == 1 ? "" : "s"} selected
        </span>
        <div class="todo-list-bulk-buttons">
          <button
            class="todo-list-bulk-complete"
            onClick={this.handleBulkComplete}
          >
            Complete All
          </button>
          <button
            class="todo-list-bulk-delete"
            onClick={this.handleBulkDelete}
          >
            Delete All
          </button>
          <button
            class="todo-list-bulk-clear"
            onClick={this.handleClearSelection}
          >
            Clear Selection
          </button>
        </div>
      </div>
    )
  }

  renderQuickActions(hasCompleted) {
    return (
      <div class="todo-list-quick-actions">
        {hasCompleted && (
          <button
            class="todo-list-quick-action todo-list-clear-completed"
            onClick={this.handleClearCompleted}
          >
            Clear Completed
          </button>
        )}
        <button
          class="todo-list-quick-action todo-list-select-all"
          onClick={this.handleSelectAll}
        >
          Select All
        </button>
      </div>
    )
  }

  // Computed properties and utility methods
  isEmpty() {
    const todos = this.props.todos || []
    return todos.length == 0
  }

  hasActiveTodos() {
    const todos = this.props.todos || []
    return todos.some(todo => todo.completed == false)
  }

  hasCompletedTodos() {
    const todos = this.props.todos || []
    return todos.some(todo => todo.completed)
  }

  getFilteredAndSortedTodos() {
    let todos = this.props.todos || []

    // Apply filtering based on props.filter
    const filter = this.props.filter || "all"
    if (filter == "active") {
      todos = todos.filter(todo => todo.completed == false)
    } else if (filter == "completed") {
      todos = todos.filter(todo => todo.completed)
    }

    // Apply sorting
    todos = this.sortTodos(todos, this.state.sortOrder)

    return todos
  }

  sortTodos(todos, sortOrder) {
    const sorted = todos.slice() // Create a copy to avoid mutating props

    if (sortOrder == "alphabetical") {
      sorted.sort((a, b) => {
        const textA = a.text.toLowerCase()
        const textB = b.text.toLowerCase()
        if (textA < textB) return -1
        if (textA > textB) return 1
        return 0
      })
    } else if (sortOrder == "completed") {
      sorted.sort((a, b) => {
        // Incomplete todos first, then completed
        if (a.completed == b.completed) {
          // If same completion status, sort by creation date
          return new Date(b.createdAt) - new Date(a.createdAt)
        }
        return a.completed ? 1 : -1
      })
    } else {
      // Default: sort by creation date (newest first)
      sorted.sort((a, b) => {
        return new Date(b.createdAt) - new Date(a.createdAt)
      })
    }

    return sorted
  }

  isItemSelected(todoId) {
    return this.state.selectedItems.includes(todoId)
  }

  // Event handlers
  handleRetry(event) {
    event.preventDefault()
    this.setState({
      error: "",
      isLoading: true
    })

    // Simulate retry by calling parent refresh if available
    if (this.props.onRefresh && typeof this.props.onRefresh == "function") {
      try {
        this.props.onRefresh()
        this.setState({ isLoading: false })
      } catch (error) {
        this.setState({
          error: "Failed to refresh todos. Please try again.",
          isLoading: false
        })
      }
    } else {
      this.setState({ isLoading: false })
    }
  }

  handleShowAll(event) {
    event.preventDefault()
    if (this.props.onFilterChange && typeof this.props.onFilterChange == "function") {
      this.props.onFilterChange("all")
    }
  }

  handleShowActive(event) {
    event.preventDefault()
    if (this.props.onFilterChange && typeof this.props.onFilterChange == "function") {
      this.props.onFilterChange("active")
    }
  }

  handleSortChange(event) {
    const newSortOrder = event.target.value
    this.setState({ sortOrder: newSortOrder })

    // Notify parent of sort change if callback provided
    if (this.props.onSortChange && typeof this.props.onSortChange == "function") {
      this.props.onSortChange(newSortOrder)
    }
  }

  handleItemSelect(todoId, isSelected) {
    let selectedItems = this.state.selectedItems.slice()

    if (isSelected) {
      if (selectedItems.includes(todoId) == false) {
        selectedItems.push(todoId)
      }
    } else {
      selectedItems = selectedItems.filter(id => id != todoId)
    }

    this.setState({ selectedItems })

    // Notify parent of selection change
    if (this.props.onSelectionChange && typeof this.props.onSelectionChange == "function") {
      this.props.onSelectionChange(selectedItems)
    }
  }

  handleSelectAll(event) {
    event.preventDefault()
    const todos = this.getFilteredAndSortedTodos()
    const allIds = todos.map(todo => todo.id)
    this.setState({ selectedItems: allIds })

    if (this.props.onSelectionChange && typeof this.props.onSelectionChange == "function") {
      this.props.onSelectionChange(allIds)
    }
  }

  handleClearSelection(event) {
    event.preventDefault()
    this.setState({ selectedItems: [] })

    if (this.props.onSelectionChange && typeof this.props.onSelectionChange == "function") {
      this.props.onSelectionChange([])
    }
  }

  handleBulkComplete(event) {
    event.preventDefault()
    const selectedIds = this.state.selectedItems

    if (selectedIds.length == 0) {
      return
    }

    if (this.props.onBulkToggle && typeof this.props.onBulkToggle == "function") {
      this.props.onBulkToggle(selectedIds, true)
    }

    // Clear selection after bulk action
    this.setState({ selectedItems: [] })
  }

  handleBulkDelete(event) {
    event.preventDefault()
    const selectedIds = this.state.selectedItems

    if (selectedIds.length == 0) {
      return
    }

    // Show confirmation for bulk delete
    const confirmMessage = `Are you sure you want to delete ${selectedIds.length} todo${selectedIds.length == 1 ? "" : "s"}?`
    if (confirm(confirmMessage)) {
      if (this.props.onBulkDelete && typeof this.props.onBulkDelete == "function") {
        this.props.onBulkDelete(selectedIds)
      }

      // Clear selection after bulk action
      this.setState({ selectedItems: [] })
    }
  }

  handleClearCompleted(event) {
    event.preventDefault()
    if (this.props.onClearCompleted && typeof this.props.onClearCompleted == "function") {
      this.props.onClearCompleted()
    }
  }

  // Public methods for external control
  setLoading(isLoading) {
    this.setState({ isLoading: Boolean(isLoading) })
  }

  setError(error) {
    this.setState({
      error: error || "",
      isLoading: false
    })
  }

  clearError() {
    this.setState({ error: "" })
  }

  refresh() {
    this.handleRetry({ preventDefault: () => {} })
  }

  getSelectedItems() {
    return this.state.selectedItems.slice()
  }

  selectItem(todoId) {
    this.handleItemSelect(todoId, true)
  }

  deselectItem(todoId) {
    this.handleItemSelect(todoId, false)
  }

  selectAll() {
    this.handleSelectAll({ preventDefault: () => {} })
  }

  clearSelection() {
    this.handleClearSelection({ preventDefault: () => {} })
  }

  setSortOrder(sortOrder) {
    if (["created", "alphabetical", "completed"].includes(sortOrder)) {
      this.setState({ sortOrder })
    }
  }

  getSortOrder() {
    return this.state.sortOrder
  }

  getStats() {
    const todos = this.getFilteredAndSortedTodos()
    const total = todos.length
    const completed = todos.filter(todo => todo.completed).length
    const active = total - completed

    return {
      total,
      active,
      completed,
      selected: this.state.selectedItems.length
    }
  }
}

// TodoFilter component for filtering todos by completion status
component TodoFilter {
  state {
    currentFilter: string = "all"
    isChanging: boolean = false
    error: string = ""
    urlSyncEnabled: boolean = true
  }

  render() {
    <div class={this.getFilterClass()}>
      {this.renderFilterButtons()}
      {this.renderError()}
    </div>
  }

  computed getFilterClass() {
    let classes = "todo-filter"
    if (this.state.isChanging) {
      classes = classes + " todo-filter-changing"
    }
    if (this.state.error.length > 0) {
      classes = classes + " todo-filter-error"
    }
    return classes
  }

  renderFilterButtons() {
    const filters = this.getFilterOptions()

    return (
      <div class="todo-filter-buttons">
        <span class="todo-filter-label">Show:</span>
        <div class="todo-filter-button-group">
          {filters.map(filter => this.renderFilterButton(filter))}
        </div>
      </div>
    )
  }

  renderFilterButton(filter) {
    const isActive = this.isFilterActive(filter.value)
    const buttonClass = this.getButtonClass(filter.value, isActive)

    return (
      <button
        key={filter.value}
        class={buttonClass}
        onClick={() => this.handleFilterClick(filter.value)}
        disabled={this.state.isChanging}
        title={filter.description}
        aria-pressed={isActive}
      >
        <span class="todo-filter-button-text">{filter.label}</span>
his.renderFilterCount(filter.value)}
      </button>
    )
  }

  computed getButtonClass() {
    return (filterValue, isActive) => {
      let classes = "todo-filter-button"
      if (isActive) {
        classes = classes + " todo-filter-button-active"
      }
      if (this.state.isChanging) {
        classes = classes + " todo-filter-button-disabled"
      }
      classes = classes + " todo-filter-button-" + filterValue
      return classes
    }
  }

  renderFilterCount(filterValue) {
    if (this.props.showCounts == false) {
      return null
    }

    const count = this.getFilterCount(filterValue)
    if (count == null) {
      return null
    }

    return (
      <span class="todo-filter-button-count">
        ({count})
      </span>
    )
  }

  renderError() {
    if (this.state.error.length == 0) {
      return null
    }

    return (
      <div class="todo-filter-error">
        <span class="todo-filter-error-icon">⚠️</span>
        <span class="todo-filter-error-message">{this.state.error}</span>
        <button
          class="todo-filter-error-dismiss"
          onClick={this.handleDismissError}
          title="Dismiss error"
        >
          ×
        </button>
      </div>
    )
  }

  // Computed properties and utility methods
  getFilterOptions() {
    return [
      {
        value: "all",
        label: "All",
        description: "Show all todos"
      },
      {
        value: "active",
        label: "Active",
        description: "Show only incomplete todos"
      },
      {
        value: "completed",
        label: "Completed",
        description: "Show only completed todos"
      }
    ]
  }

  isFilterActive(filterValue) {
    const currentFilter = this.getCurrentFilter()
    return currentFilter == filterValue
  }

  getCurrentFilter() {
    // Priority: props.current > state.currentFilter > URL > default
    if (this.props.current) {
      return this.props.current
    }

    if (this.state.urlSyncEnabled) {
      const urlFilter = this.getFilterFromUrl()
      if (urlFilter) {
        return urlFilter
      }
    }

    return this.state.currentFilter
  }

  getFilterFromUrl() {
    if (typeof window == "undefined") {
      return null
    }

    try {
      const urlParams = new URLSearchParams(window.location.search)
      const filterParam = urlParams.get("filter")

      if (filterParam && this.isValidFilter(filterParam)) {
        return filterParam
      }

      // Also check hash-based routing
      const hash = window.location.hash
      if (hash.includes("filter=")) {
        const hashFilter = hash.split("filter=")[1]?.split("&")[0]
        if (hashFilter && this.isValidFilter(hashFilter)) {
          return hashFilter
        }
      }
    } catch (error) {
      console.warn("Error reading filter from URL:", error)
    }

    return null
  }

  isValidFilter(filterValue) {
    const validFilters = this.getFilterOptions().map(f => f.value)
    return validFilters.includes(filterValue)
  }

  getFilterCount(filterValue) {
    if (this.props.todos == null || this.props.todos.length == 0) {
      return 0
    }

    const todos = this.props.todos

    if (filterValue == "all") {
      return todos.length
    } else if (filterValue == "active") {
      return todos.filter(todo => todo.completed == false).length
    } else if (filterValue == "completed") {
      return todos.filter(todo => todo.completed).length
    }

    return null
  }

  // Event handlers
  handleFilterClick(filterValue) {
    if (this.state.isChanging) {
      return
    }

    if (this.isFilterActive(filterValue)) {
      return // Already active, no need to change
    }

    if (this.isValidFilter(filterValue) == false) {
      this.setState({
        error: `Invalid filter: ${filterValue}`
      })
      return
    }

    this.setState({
      isChanging: true,
      error: ""
    })

    try {
      // Update internal state
      this.setState({
        currentFilter: filterValue
      })

      // Update URL if enabled
      if (this.state.urlSyncEnabled) {
        this.updateUrl(filterValue)
      }

all parent callback
      if (this.props.onChange && typeof this.props.onChange == "function") {
        this.props.onChange(filterValue)
      }

      // Persist filter state
      this.persistFilterState(filterValue)

    } catch (error) {
      console.error("Error changing filter:", error)
      this.setState({
        error: "Failed to change filter. Please try again."
      })
    } finally {
      this.setState({
        isChanging: false
      })
    }
  }

  handleDismissError(event) {
    event.preventDefault()
    event.stopPropagation()
    this.setState({ error: "" })
  }

  // URL management
  updateUrl(filterValue) {
    if (typeof window == "undefined") {
      return
    }

    try {
      const url = new URL(window.location)

      if (filterValue == "all") {
        // Remove filter parameter for "all" to keep URLs clean
        url.searchParams.delete("filter")
      } else {
        url.searchParams.set("filter", filterValue)
      }

      // Update URL without triggering page reload
      window.history.replaceState(
        { filter: filterValue },
        "",
        url.toString()
      )

      // Dispatch custom event for other components to listen
      window.dispatchEvent(new CustomEvent("filterChanged", {
        detail: { filter: filterValue, source: "url" }
      }))

    } catch (error) {
      console.warn("Error updating URL:", error)
    }
  }

  // Persistence
  persistFilterState(filterValue) {
    if (typeof localStorage == "undefined") {
      return
    }

    try {
      const filterState = {
        filter: filterValue,
        timestamp: Date.now()
      }

      localStorage.setItem("todoapp_filter_state", JSON.stringify(filterState))
    } catch (error) {
      console.warn("Error persisting filter state:", error)
    }
  }

  loadPersistedFilterState() {
    if (typeof localStorage == "undefined") {
      return null
    }

    try {
      const stored = localStorage.getItem("todoapp_filter_state")
      if (stored == null) {
        return null
      }

      const filterState = JSON.parse(stored)
      if (filterState && filterState.filter && this.isValidFilter(filterState.filter)) {
        return filterState.filter
      }
    } catch (error) {
      console.warn("Error loading persisted filter state:", error)
    }

    return null
  }

  clearPersistedFilterState() {
    if (typeof localStorage == "undefined") {
      return
    }

    try {
      localStorage.removeItem("todoapp_filter_state")
    } catch (error) {
      console.warn("Error clearing persisted filter state:", error)
    }
  }

  // Lifecycle methods
  componentDidMount() {
    // Initialize filter from URL or persisted state
    this.initializeFilter()

    // Listen for URL changes (browser back/forward)
    if (typeof window != "undefined" && this.state.urlSyncEnabled) {
      window.addEventListener("popstate", this.handleUrlChange)
      window.addEventListener("filterChanged", this.handleExternalFilterChange)
    }
  }

  componentWillUnmount() {
    // Clean up event listeners
    if (typeof window != "undefined") {
      window.removeEventListener("popstate", this.handleUrlChange)
      window.removeEventListener("filterChanged", this.handleExternalFilterChange)
    }
  }

  componentDidUpdate(prevProps) {
    // React to prop changes
    if (prevProps.current != this.props.current) {
      this.syncWithProps()
    }
  }

  initializeFilter() {
    let initialFilter = "all"

    // Priority: URL > persisted state > props > default
    const urlFilter = this.getFilterFromUrl()
    const persistedFilter = this.loadPersistedFilterState()

    if (urlFilter) {
      initialFilter = urlFilter
    } else if (persistedFilter) {
      initialFilter = persistedFilter
      // Update URL to match persisted state
      if (this.state.urlSyncEnabled) {
        this.updateUrl(initialFilter)
      }
    } else if (this.props.current && this.isValidFilter(this.props.current)) {
      initialFilter = this.props.current
    }

    this.setState({
      currentFilter: initialFilter
    })

    // Notify parent of initial filter
    if (this.props.onChange && typeof this.props.onChange == "function") {
      this.props.onChange(initialFilter)
    }
  }

  syncWithProps() {
    if (this.props.current && this.isValidFilter(this.props.current)) {
      const newFilter = this.props.current
      if (newFilter != this.state.currentFilter) {
        this.setState({
          currentFilter: newFilter
        })

        if (this.state.urlSyncEnabled) {
          this.updateUrl(newFilter)
        }

        this.persistFilterState(newFilter)
      }
    }
  }

  handleUrlChange = (event) => {
    const urlFilter = this.getFilterFromUrl()
    if (urlFilter && urlFilter != this.state.currentFilter) {
      this.setState({
        currentFilter: urlFilter
      })

      if (this.props.onChange && typeof this.props.onChange == "function") {
        this.props.onChange(urlFilter)
      }

      this.persistFilterState(urlFilter)
    }
  }

  handleExternalFilterChange = (event) => {
    // Handle filter changes from other sources
    if (event.detail && event.detail.filter && event.detail.source != "url") {
      const newFilter = event.detail.filter
      if (this.isValidFilter(newFilter) && newFilter != this.state.currentFilter) {
        this.setState({
          currentFilter: newFilter
        })
      }
    }
  }

  // Public methods for external control
  setFilter(filterValue) {
    if (this.isValidFilter(filterValue)) {
      this.handleFilterClick(filterValue)
      return true
    }
    return false
  }

  getFilter() {
    return this.getCurrentFilter()
  }

  resetFilter() {
    this.setFilter("all")
  }

  enableUrlSync() {
    this.setState({ urlSyncEnabled: true })
  }

  disableUrlSync() {
    this.setState({ urlSyncEnabled: false })
  }

  isUrlSyncEnabled() {
    return this.state.urlSyncEnabled
  }

  clearError() {
    this.setState({ error: "" })
  }

  getFilterStats() {
    const options = this.getFilterOptions()
    const stats = {}

    options.forEach(option => {
      stats[option.value] = {
        label: option.label,
        count: this.getFilterCount(option.value),
        active: this.isFilterActive(option.value)
      }
    })

    return stats
  }

  // Utility methods for testing and debugging
  getDebugInfo() {
    return {
      currentFilter: this.getCurrentFilter(),
      stateFilter: this.state.currentFilter,
      urlFilter: this.getFilterFromUrl(),
      persistedFilter: this.loadPersistedFilterState(),
      propsFilter: this.props.current,
      urlSyncEnabled: this.state.urlSyncEnabled,
      isChanging: this.state.isChanging,
      error: this.state.error
    }
  }
}