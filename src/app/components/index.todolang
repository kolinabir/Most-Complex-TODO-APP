// TodoLang Application Components
// UI components for the todo application

// TodoInput component for adding new todos
component TodoInput {
  state {
    inputValue: string = ""
    isValid: boolean = true
    errorMessage: string = ""
    isSubmitting: boolean = false
  }

  render() {
    <div class="todo-input-container">
      <form class="todo-input-form" onSubmit={this.handleSubmit}>
        <input
          type="text"
          class={this.getInputClass()}
          placeholder="What needs to be done?"
          value={this.state.inputValue}
          onInput={this.handleInput}
          onKeyDown={this.handleKeyDown}
          disabled={this.state.isSubmitting}
          autoFocus={true}
        />
        <button
          type="submit"
          class="todo-input-submit"
          disabled={this.state.isSubmitting || this.state.inputValue.trim().length == 0}
        >
          Add
        </button>
      </form>
      {this.renderErrorMessage()}
    </div>
  }

  computed getInputClass() {
    let classes = "todo-input"
    if (this.state.isValid == false) {
      classes = classes + " todo-input-error"
    }
    if (this.state.isSubmitting) {
      classes = classes + " todo-input-submitting"
    }
    return classes
  }

  renderErrorMessage() {
    if (this.state.isValid == false && this.state.errorMessage.length > 0) {
      return <div class="todo-input-error-message">{this.state.errorMessage}</div>
    }
    return null
  }

  handleInput(event) {
    const value = event.target.value
    this.setState({
      inputValue: value,
      isValid: true,
      errorMessage: ""
    })
  }

  handleKeyDown(event) {
    if (event.key == "Enter") {
      event.preventDefault()
      this.submitTodo()
    }
  }

  handleSubmit(event) {
    event.preventDefault()
    this.submitTodo()
  }

  submitTodo() {
    if (this.state.isSubmitting) {
      return
    }

    const trimmedValue = this.state.inputValue.trim()

    // Validate input
    const validation = this.validateInput(trimmedValue)
    if (validation.isValid == false) {
      this.setState({
        isValid: false,
        errorMessage: validation.error
      })
      return
    }

    // Set submitting state
    this.setState({
      isSubmitting: true,
      isValid: true,
      errorMessage: ""
    })

    try {
      // Call parent callback if provided
      if (this.props.onAdd && typeof this.props.onAdd == "function") {
        this.props.onAdd(trimmedValue)
      }

      // Clear input on successful submission
      this.clearInput()
    } catch (error) {
      this.setState({
        isValid: false,
        errorMessage: "Failed to add todo. Please try again."
      })
    } finally {
      this.setState({
        isSubmitting: false
      })
    }
  }

  validateInput(text) {
    const result = {
      isValid: false,
      error: ""
    }

    if (text == null || text.length == 0) {
      result.error = "Todo text cannot be empty"
      return result
    }

    if (text.length > 500) {
      result.error = "Todo text cannot exceed 500 characters"
      return result
    }

    // Check for only whitespace
    if (text.replace(/\s/g, "").length == 0) {
      result.error = "Todo text cannot be only whitespace"
      return result
    }

    result.isValid = true
    return result
  }

  clearInput() {
    this.setState({
      inputValue: "",
      isValid: true,
      errorMessage: "",
      isSubmitting: false
    })
  }

  focus() {
    // Method to programmatically focus the input
    if (this._domNode) {
      const input = this._domNode.querySelector(".todo-input")
      if (input) {
        input.focus()
      }
    }
  }

  getValue() {
    return this.state.inputValue
  }

  setValue(value) {
    this.setState({
      inputValue: value || "",
      isValid: true,
      errorMessage: ""
    })
  }

  reset() {
    this.clearInput()
  }
}

// TodoItem component for individual todo items
component TodoItem {
  state {
    isEditing: boolean = false
    editValue: string = ""
    showDeleteConfirm: boolean = false
    isDeleting: boolean = false
    isToggling: boolean = false
    isUpdating: boolean = false
    editError: string = ""
  }

  render() {
    <div class={this.getItemClass()}>
      {this.renderDeleteConfirmDialog()}
      <div class="todo-item-content">
        <div class="todo-item-main">
          {this.renderToggleButton()}
          {this.renderContent()}
        </div>
        {this.renderActions()}
      </div>
    </div>
  }

  computed getItemClass() {
    let classes = "todo-item"
    if (this.props.todo && this.props.todo.completed) {
      classes = classes + " todo-item-completed"
    }
    if (this.state.isEditing) {
      classes = classes + " todo-item-editing"
    }
    if (this.state.isDeleting) {
      classes = classes + " todo-item-deleting"
    }
    return classes
  }

  renderToggleButton() {
    return (
      <button
        class="todo-item-toggle"
        onClick={this.handleToggle}
        disabled={this.state.isToggling || this.state.isDeleting}
        title={this.props.todo && this.props.todo.completed ? "Mark as incomplete" : "Mark as complete"}
      >
        <input
          type="checkbox"
          checked={this.props.todo && this.props.todo.completed}
          disabled={true}
          tabIndex={-1}
        />
        <span class="todo-item-toggle-indicator"></span>
      </button>
    )
  }

  renderContent() {
    if (this.state.isEditing) {
      return this.renderEditMode()
    }
    return this.renderViewMode()
  }

  renderViewMode() {
    return (
      <div class="todo-item-view">
        <span
          class="todo-item-text"
          onDoubleClick={this.handleStartEdit}
          title="Double-click to edit"
        >
          {this.props.todo ? this.props.todo.text : ""}
        </span>
        {this.renderTimestamp()}
      </div>
    )
  }

  renderEditMode() {
    return (
      <div class="todo-item-edit">
        <input
          type="text"
          class={this.getEditInputClass()}
          value={this.state.editValue}
          onInput={this.handleEditInput}
          onKeyDown={this.handleEditKeyDown}
          onBlur={this.handleEditBlur}
          autoFocus={true}
          disabled={this.state.isUpdating}
        />
        {this.renderEditError()}
        <div class="todo-item-edit-actions">
          <button
            class="todo-item-edit-save"
            onClick={this.handleSaveEdit}
            disabled={this.state.isUpdating || this.state.editValue.trim().length == 0}
          >
            Save
          </button>
          <button
            class="todo-item-edit-cancel"
            onClick={this.handleCancelEdit}
            disabled={this.state.isUpdating}
          >
            Cancel
          </button>
        </div>
      </div>
    )
  }

  computed getEditInputClass() {
    let classes = "todo-item-edit-input"
    if (this.state.editError.length > 0) {
      classes = classes + " todo-item-edit-input-error"
    }
    if (this.state.isUpdating) {
      classes = classes + " todo-item-edit-input-updating"
    }
    return classes
  }

  renderEditError() {
    if (this.state.editError.length > 0) {
      return <div class="todo-item-edit-error">{this.state.editError}</div>
    }
    return null
  }

  renderTimestamp() {
    if (this.props.todo && this.props.todo.createdAt) {
      const date = new Date(this.props.todo.createdAt)
      const formatted = this.formatDate(date)
      return <span class="todo-item-timestamp" title={date.toString()}>{formatted}</span>
    }
    return null
  }

  renderActions() {
    if (this.state.isEditing) {
      return null
    }

    return (
      <div class="todo-item-actions">
        <button
          class="todo-item-edit-btn"
          onClick={this.handleStartEdit}
          disabled={this.state.isDeleting || this.state.isToggling}
          title="Edit todo"
        >
          Edit
        </button>
        <button
          class="todo-item-delete-btn"
          onClick={this.handleStartDelete}
          disabled={this.state.isDeleting || this.state.isToggling}
          title="Delete todo"
        >
          Delete
        </button>
      </div>
    )
  }

  renderDeleteConfirmDialog() {
    if (this.state.showDeleteConfirm == false) {
      return null
    }

    return (
      <div class="todo-item-delete-confirm-overlay">
        <div class="todo-item-delete-confirm-dialog">
          <div class="todo-item-delete-confirm-content">
            <h3>Confirm Delete</h3>
            <p>Are you sure you want to delete this todo?</p>
            <p class="todo-item-delete-confirm-text">"{this.props.todo ? this.props.todo.text : ""}"</p>
          </div>
          <div class="todo-item-delete-confirm-actions">
            <button
              class="todo-item-delete-confirm-yes"
              onClick={this.handleConfirmDelete}
              disabled={this.state.isDeleting}
            >
              {this.state.isDeleting ? "Deleting..." : "Yes, Delete"}
            </button>
            <button
              class="todo-item-delete-confirm-no"
              onClick={this.handleCancelDelete}
              disabled={this.state.isDeleting}
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    )
  }

  // Event handlers
  handleToggle(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isToggling || this.state.isDeleting || this.state.isEditing) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({ isToggling: true })

    try {
      if (this.props.onToggle && typeof this.props.onToggle == "function") {
        this.props.onToggle(this.props.todo.id)
      }
    } catch (error) {
      console.error("Error toggling todo:", error)
    } finally {
      this.setState({ isToggling: false })
    }
  }

  handleStartEdit(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting || this.state.isToggling) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({
      isEditing: true,
      editValue: this.props.todo.text,
      editError: ""
    })
  }

  handleEditInput(event) {
    const value = event.target.value
    this.setState({
      editValue: value,
      editError: ""
    })
  }

  handleEditKeyDown(event) {
    if (event.key == "Enter") {
      event.preventDefault()
      this.handleSaveEdit()
    } else if (event.key == "Escape") {
      event.preventDefault()
      this.handleCancelEdit()
    }
  }

  handleEditBlur(event) {
    // Don't auto-save on blur to avoid conflicts with save/cancel buttons
    // User must explicitly save or cancel
  }

  handleSaveEdit(event) {
    if (event) {
      event.preventDefault()
      event.stopPropagation()
    }

    if (this.state.isUpdating) {
      return
    }

    const trimmedValue = this.state.editValue.trim()

    // Validate the edit
    const validation = this.validateEditText(trimmedValue)
    if (validation.isValid == false) {
      this.setState({
        editError: validation.error
      })
      return
    }

    // Check if text actually changed
    if (this.props.todo && trimmedValue == this.props.todo.text) {
      this.handleCancelEdit()
      return
    }

    this.setState({ isUpdating: true })

    try {
      if (this.props.onEdit && typeof this.props.onEdit == "function") {
        this.props.onEdit(this.props.todo.id, trimmedValue)
      }

      this.setState({
        isEditing: false,
        editValue: "",
        editError: "",
        isUpdating: false
      })
    } catch (error) {
      this.setState({
        editError: "Failed to update todo. Please try again.",
        isUpdating: false
      })
    }
  }

  handleCancelEdit(event) {
    if (event) {
      event.preventDefault()
      event.stopPropagation()
    }

    this.setState({
      isEditing: false,
      editValue: "",
      editError: "",
      isUpdating: false
    })
  }

  handleStartDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting || this.state.isToggling || this.state.isEditing) {
      return
    }

    this.setState({
      showDeleteConfirm: true
    })
  }

  handleConfirmDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    if (this.state.isDeleting) {
      return
    }

    if (this.props.todo == null) {
      return
    }

    this.setState({ isDeleting: true })

    try {
      if (this.props.onDelete && typeof this.props.onDelete == "function") {
        this.props.onDelete(this.props.todo.id)
      }

      this.setState({
        showDeleteConfirm: false,
        isDeleting: false
      })
    } catch (error) {
      console.error("Error deleting todo:", error)
      this.setState({
        isDeleting: false
      })
    }
  }

  handleCancelDelete(event) {
    event.preventDefault()
    event.stopPropagation()

    this.setState({
      showDeleteConfirm: false
    })
  }

  // Utility methods
  validateEditText(text) {
    const result = {
      isValid: false,
      error: ""
    }

    if (text == null || text.length == 0) {
      result.error = "Todo text cannot be empty"
      return result
    }

    if (text.length > 500) {
      result.error = "Todo text cannot exceed 500 characters"
      return result
    }

    // Check for only whitespace
    if (text.replace(/\s/g, "").length == 0) {
      result.error = "Todo text cannot be only whitespace"
      return result
    }

    result.isValid = true
    return result
  }

  formatDate(date) {
    if (date == null) {
      return ""
    }

    const now = new Date()
    const diffMs = now.getTime() - date.getTime()
    const diffMinutes = Math.floor(diffMs / (1000 * 60))
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

    if (diffMinutes < 1) {
      return "just now"
    } else if (diffMinutes < 60) {
      return diffMinutes + " min ago"
    } else if (diffHours < 24) {
      return diffHours + " hour" + (diffHours == 1 ? "" : "s") + " ago"
    } else if (diffDays < 7) {
      return diffDays + " day" + (diffDays == 1 ? "" : "s") + " ago"
    } else {
      return date.toLocaleDateString()
    }
  }

  // Public methods for external control
  startEdit() {
    if (this.state.isDeleting || this.state.isToggling) {
      return false
    }

    if (this.props.todo == null) {
      return false
    }

    this.setState({
      isEditing: true,
      editValue: this.props.todo.text,
      editError: ""
    })
    return true
  }

  cancelEdit() {
    this.handleCancelEdit()
  }

  isInEditMode() {
    return this.state.isEditing
  }

  focus() {
    if (this.state.isEditing) {
      // Focus the edit input
      if (this._domNode) {
        const input = this._domNode.querySelector(".todo-item-edit-input")
        if (input) {
          input.focus()
        }
      }
    }
  }
}

// TodoList component for displaying multiple todo items
component TodoList {
  state {
    isLoading: boolean = false
    error: string = ""
    selectedItems: string[] = []
    sortOrder: string = "created" // "created", "alphabetical", "completed"
    showCompleted: boolean = true
  }

  render() {
    <div class={this.getListClass()}>
      {this.renderContent()}
    </div>
  }

  computed getListClass() {
    let classes = "todo-list"
    if (this.state.isLoading) {
      classes = classes + " todo-list-loading"
    }
    if (this.state.error.length > 0) {
      classes = classes + " todo-list-error"
    }
    if (this.isEmpty()) {
      classes = classes + " todo-list-empty"
    }
    return classes
  }

  renderContent() {
    if (this.state.error.length > 0) {
      return this.renderError()
    }

    if (this.state.isLoading) {
      return this.renderLoading()
    }

    if (this.isEmpty()) {
      return this.renderEmptyState()
    }

    return this.renderTodoItems()
  }

  renderError() {
    return (
      <div class="todo-list-error-container">
        <div class="todo-list-error-icon">⚠️</div>
        <div class="todo-list-error-message">{this.state.error}</div>
        <button
          class="todo-list-error-retry"
          onClick={this.handleRetry}
        >
          Try Again
        </button>
      </div>
    )
  }

  renderLoading() {
    return (
      <div class="todo-list-loading-container">
        <div class="todo-list-loading-spinner"></div>
        <div class="todo-list-loading-text">Loading todos...</div>
      </div>
    )
  }

  renderEmptyState() {
    const filter = this.props.filter || "all"
    const emptyMessage = this.getEmptyMessage(filter)
    const emptyIcon = this.getEmptyIcon(filter)

    return (
      <div class="todo-list-empty-container">
        <div class="todo-list-empty-icon">{emptyIcon}</div>
        <div class="todo-list-empty-message">{emptyMessage}</div>
        {this.renderEmptyStateActions(filter)}
      </div>
    )
  }

  getEmptyMessage(filter) {
    if (filter == "active") {
      return "No active todos! You're all caught up."
    }
    if (filter == "completed") {
      return "No completed todos yet."
    }
    return "No todos yet. Add one above to get started!"
  }

  getEmptyIcon(filter) {
    if (filter == "active") {
      return "✅"
    }
    if (filter == "completed") {
      return "📝"
    }
    return "📋"
  }

  renderEmptyStateActions(filter) {
    if (filter == "active" && this.hasCompletedTodos()) {
      return (
        <div class="todo-list-empty-actions">
          <button
            class="todo-list-empty-action"
            onClick={this.handleShowAll}
          >
            View All Todos
          </button>
        </div>
      )
    }

    if (filter == "completed" && this.hasActiveTodos()) {
      return (
        <div class="todo-list-empty-actions">
          <button
            class="todo-list-empty-action"
            onClick={this.handleShowActive}
          >
            View Active Todos
          </button>
        </div>
      )
    }

    return null
  }

  renderTodoItems() {
    const todos = this.getFilteredAndSortedTodos()

    return (
      <div class="todo-list-items-container">
        {this.renderListHeader(todos)}
        <div class="todo-list-items">
          {todos.map(todo => this.renderTodoItem(todo))}
        </div>
        {this.renderListFooter(todos)}
      </div>
    )
  }

  renderListHeader(todos) {
    if (todos.length == 0) {
      return null
    }

    const totalCount = todos.length
    const completedCount = todos.filter(todo => todo.completed).length
    const activeCount = totalCount - completedCount

    return (
      <div class="todo-list-header">
        <div class="todo-list-stats">
          <span class="todo-list-stat">
            <span class="todo-list-stat-number">{totalCount}</span>
            <span class="todo-list-stat-label">total</span>
          </span>
          <span class="todo-list-stat">
            <span class="todo-list-stat-number">{activeCount}</span>
            <span class="todo-list-stat-label">active</span>
          </span>
          <span class="todo-list-stat">
            <span class="todo-list-stat-number">{completedCount}</span>
            <span class="todo-list-stat-label">completed</span>
          </span>
        </div>
        {this.renderSortControls()}
      </div>
    )
  }

  renderSortControls() {
    return (
      <div class="todo-list-sort-controls">
        <label class="todo-list-sort-label">Sort by:</label>
        <select
          class="todo-list-sort-select"
          value={this.state.sortOrder}
          onChange={this.handleSortChange}
        >
          <option value="created">Date Created</option>
          <option value="alphabetical">Alphabetical</option>
          <option value="completed">Completion Status</option>
        </select>
      </div>
    )
  }

  renderTodoItem(todo) {
    return (
      <TodoItem
        key={todo.id}
        todo={todo}
        onToggle={this.props.onToggle}
        onEdit={this.props.onEdit}
        onDelete={this.props.onDelete}
        isSelected={this.isItemSelected(todo.id)}
        onSelect={this.handleItemSelect}
      />
    )
  }

  renderListFooter(todos) {
    if (todos.length == 0) {
      return null
    }

    const hasCompleted = todos.some(todo => todo.completed)
    const hasSelected = this.state.selectedItems.length > 0

    return (
      <div class="todo-list-footer">
        {this.renderBulkActions(hasSelected)}
        {this.renderQuickActions(hasCompleted)}
      </div>
    )
  }

  renderBulkActions(hasSelected) {
    if (hasSelected == false) {
      return null
    }

    const selectedCount = this.state.selectedItems.length

    return (
      <div class="todo-list-bulk-actions">
        <span class="todo-list-bulk-count">
          {selectedCount} item{selectedCount == 1 ? "" : "s"} selected
        </span>
        <div class="todo-list-bulk-buttons">
          <button
            class="todo-list-bulk-complete"
            onClick={this.handleBulkComplete}
          >
            Complete All
          </button>
          <button
            class="todo-list-bulk-delete"
            onClick={this.handleBulkDelete}
          >
            Delete All
          </button>
          <button
            class="todo-list-bulk-clear"
            onClick={this.handleClearSelection}
          >
            Clear Selection
          </button>
        </div>
      </div>
    )
  }

  renderQuickActions(hasCompleted) {
    return (
      <div class="todo-list-quick-actions">
        {hasCompleted && (
          <button
            class="todo-list-quick-action todo-list-clear-completed"
            onClick={this.handleClearCompleted}
          >
            Clear Completed
          </button>
        )}
        <button
          class="todo-list-quick-action todo-list-select-all"
          onClick={this.handleSelectAll}
        >
          Select All
        </button>
      </div>
    )
  }

  // Computed properties and utility methods
  isEmpty() {
    const todos = this.props.todos || []
    return todos.length == 0
  }

  hasActiveTodos() {
    const todos = this.props.todos || []
    return todos.some(todo => todo.completed == false)
  }

  hasCompletedTodos() {
    const todos = this.props.todos || []
    return todos.some(todo => todo.completed)
  }

  getFilteredAndSortedTodos() {
    let todos = this.props.todos || []

    // Apply filtering based on props.filter
    const filter = this.props.filter || "all"
    if (filter == "active") {
      todos = todos.filter(todo => todo.completed == false)
    } else if (filter == "completed") {
      todos = todos.filter(todo => todo.completed)
    }

    // Apply sorting
    todos = this.sortTodos(todos, this.state.sortOrder)

    return todos
  }

  sortTodos(todos, sortOrder) {
    const sorted = todos.slice() // Create a copy to avoid mutating props

    if (sortOrder == "alphabetical") {
      sorted.sort((a, b) => {
        const textA = a.text.toLowerCase()
        const textB = b.text.toLowerCase()
        if (textA < textB) return -1
        if (textA > textB) return 1
        return 0
      })
    } else if (sortOrder == "completed") {
      sorted.sort((a, b) => {
        // Incomplete todos first, then completed
        if (a.completed == b.completed) {
          // If same completion status, sort by creation date
          return new Date(b.createdAt) - new Date(a.createdAt)
        }
        return a.completed ? 1 : -1
      })
    } else {
      // Default: sort by creation date (newest first)
      sorted.sort((a, b) => {
        return new Date(b.createdAt) - new Date(a.createdAt)
      })
    }

    return sorted
  }

  isItemSelected(todoId) {
    return this.state.selectedItems.includes(todoId)
  }

  // Event handlers
  handleRetry(event) {
    event.preventDefault()
    this.setState({
      error: "",
      isLoading: true
    })

    // Simulate retry by calling parent refresh if available
    if (this.props.onRefresh && typeof this.props.onRefresh == "function") {
      try {
        this.props.onRefresh()
        this.setState({ isLoading: false })
      } catch (error) {
        this.setState({
          error: "Failed to refresh todos. Please try again.",
          isLoading: false
        })
      }
    } else {
      this.setState({ isLoading: false })
    }
  }

  handleShowAll(event) {
    event.preventDefault()
    if (this.props.onFilterChange && typeof this.props.onFilterChange == "function") {
      this.props.onFilterChange("all")
    }
  }

  handleShowActive(event) {
    event.preventDefault()
    if (this.props.onFilterChange && typeof this.props.onFilterChange == "function") {
      this.props.onFilterChange("active")
    }
  }

  handleSortChange(event) {
    const newSortOrder = event.target.value
    this.setState({ sortOrder: newSortOrder })

    // Notify parent of sort change if callback provided
    if (this.props.onSortChange && typeof this.props.onSortChange == "function") {
      this.props.onSortChange(newSortOrder)
    }
  }

  handleItemSelect(todoId, isSelected) {
    let selectedItems = this.state.selectedItems.slice()

    if (isSelected) {
      if (selectedItems.includes(todoId) == false) {
        selectedItems.push(todoId)
      }
    } else {
      selectedItems = selectedItems.filter(id => id != todoId)
    }

    this.setState({ selectedItems })

    // Notify parent of selection change
    if (this.props.onSelectionChange && typeof this.props.onSelectionChange == "function") {
      this.props.onSelectionChange(selectedItems)
    }
  }

  handleSelectAll(event) {
    event.preventDefault()
    const todos = this.getFilteredAndSortedTodos()
    const allIds = todos.map(todo => todo.id)
    this.setState({ selectedItems: allIds })

    if (this.props.onSelectionChange && typeof this.props.onSelectionChange == "function") {
      this.props.onSelectionChange(allIds)
    }
  }

  handleClearSelection(event) {
    event.preventDefault()
    this.setState({ selectedItems: [] })

    if (this.props.onSelectionChange && typeof this.props.onSelectionChange == "function") {
      this.props.onSelectionChange([])
    }
  }

  handleBulkComplete(event) {
    event.preventDefault()
    const selectedIds = this.state.selectedItems

    if (selectedIds.length == 0) {
      return
    }

    if (this.props.onBulkToggle && typeof this.props.onBulkToggle == "function") {
      this.props.onBulkToggle(selectedIds, true)
    }

    // Clear selection after bulk action
    this.setState({ selectedItems: [] })
  }

  handleBulkDelete(event) {
    event.preventDefault()
    const selectedIds = this.state.selectedItems

    if (selectedIds.length == 0) {
      return
    }

    // Show confirmation for bulk delete
    const confirmMessage = `Are you sure you want to delete ${selectedIds.length} todo${selectedIds.length == 1 ? "" : "s"}?`
    if (confirm(confirmMessage)) {
      if (this.props.onBulkDelete && typeof this.props.onBulkDelete == "function") {
        this.props.onBulkDelete(selectedIds)
      }

      // Clear selection after bulk action
      this.setState({ selectedItems: [] })
    }
  }

  handleClearCompleted(event) {
    event.preventDefault()
    if (this.props.onClearCompleted && typeof this.props.onClearCompleted == "function") {
      this.props.onClearCompleted()
    }
  }

  // Public methods for external control
  setLoading(isLoading) {
    this.setState({ isLoading: Boolean(isLoading) })
  }

  setError(error) {
    this.setState({
      error: error || "",
      isLoading: false
    })
  }

  clearError() {
    this.setState({ error: "" })
  }

  refresh() {
    this.handleRetry({ preventDefault: () => {} })
  }

  getSelectedItems() {
    return this.state.selectedItems.slice()
  }

  selectItem(todoId) {
    this.handleItemSelect(todoId, true)
  }

  deselectItem(todoId) {
    this.handleItemSelect(todoId, false)
  }

  selectAll() {
    this.handleSelectAll({ preventDefault: () => {} })
  }

  clearSelection() {
    this.handleClearSelection({ preventDefault: () => {} })
  }

  setSortOrder(sortOrder) {
    if (["created", "alphabetical", "completed"].includes(sortOrder)) {
      this.setState({ sortOrder })
    }
  }

  getSortOrder() {
    return this.state.sortOrder
  }

  getStats() {
    const todos = this.getFilteredAndSortedTodos()
    const total = todos.length
    const completed = todos.filter(todo => todo.completed).length
    const active = total - completed

    return {
      total,
      active,
      completed,
      selected: this.state.selectedItems.length
    }
  }
}