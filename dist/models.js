// Generated by TodoLang Compiler
// Do not edit this file directly

import { TodoLangRuntime, Component, StateManager, VirtualDOM } from "./runtime/index.js";

export class FilterType {
  constructor() {
  }
  
  static ALL() {
    return "all";
  }
  
  static ACTIVE() {
    return "active";
  }
  
  static COMPLETED() {
    return "completed";
  }
  
  static isValid(filter) {
    if (filter == "all") {
      {
        return true;
      }
    }
    if (filter == "active") {
      {
        return true;
      }
    }
    if (filter == "completed") {
      {
        return true;
      }
    }
    return false;
  }
  
}

export class Todo {
  constructor(id, text) {
    this.id = id;
    this.text = text;
    this.completed = completed !== undefined ? completed : false;
    this.createdAt = createdAt !== undefined ? createdAt : Date.now();
  }
  
  static create(text) {
    if (text == null) {
      {
        throw;
        new Error("Todo text must be a non-empty string");
      }
    }
    const trimmedText = text.trim();
    if (trimmedText.length == 0) {
      {
        throw;
        new Error("Todo text cannot be empty or whitespace only");
      }
    }
    if (trimmedText.length > 500) {
      {
        throw;
        new Error("Todo text cannot exceed 500 characters");
      }
    }
    return { id: this.generateId(), text: trimmedText, completed: false, createdAt: Date.now() };
  }
  
  static fromData(data) {
    if (data == null) {
      {
        throw;
        new Error("Invalid todo data provided");
      }
    }
    if (data.id == null) {
      {
        throw;
        new Error("Todo must have a valid id");
      }
    }
    if (data.text == null) {
      {
        throw;
        new Error("Todo must have valid text");
      }
    }
    return { id: data.id, text: data.text, completed: Boolean(data.completed), createdAt: data.createdAt ? new Date(data.createdAt) : Date.now() };
  }
  
  static generateId() {
    const timestamp = Date.now();
    const random = Math.random();
    return "todo_" + timestamp + "_" + random;
  }
  
  static validateText(text) {
    if (text == null) {
      {
        return false;
      }
    }
    const trimmed = text.trim();
    if (trimmed.length == 0) {
      {
        return false;
      }
    }
    if (trimmed.length > 500) {
      {
        return false;
      }
    }
    return true;
  }
  
  updateText(newText) {
    if (Todo.validateText(newText) == false) {
      {
        throw;
        new Error("Invalid todo text provided");
      }
    }
    this.text = newText.trim();
  }
  
  toggle() {
    this.completed = this.completed == false;
  }
  
  complete() {
    this.completed = true;
  }
  
  activate() {
    this.completed = false;
  }
  
  matchesFilter(filter) {
    if (filter == FilterType.ALL()) {
      {
        return true;
      }
    }
    if (filter == FilterType.ACTIVE()) {
      {
        return this.completed == false;
      }
    }
    if (filter == FilterType.COMPLETED()) {
      {
        return this.completed;
      }
    }
    return true;
  }
  
  toData() {
    return { id: this.id, text: this.text, completed: this.completed, createdAt: this.createdAt };
  }
  
}

export class TodoList {
  constructor() {
    this.todos = todos !== undefined ? todos : [];
    this.filter = filter !== undefined ? filter : FilterType.ALL();
  }
  
  static create() {
    return { todos: [], filter: FilterType.ALL() };
  }
  
  static fromData(data) {
    if (Array.isArray(data) == false) {
      {
        throw;
        new Error("TodoList data must be an array");
      }
    }
    const todos = data.map((item) => Todo.fromData(item));
    return { todos: todos, filter: FilterType.ALL() };
  }
  
  addTodo(text) {
    const todo = Todo.create(text);
    this.todos.push(todo);
    return todo;
  }
  
  removeTodo(id) {
    const initialLength = this.todos.length;
    this.todos = this.todos.filter((todo) => todo.id != id);
    return this.todos.length < initialLength;
  }
  
  findTodo(id) {
    return this.todos.find((todo) => todo.id == id) || null;
  }
  
  updateTodo(id, newText) {
    const todo = this.findTodo(id);
    if (todo) {
      {
        todo.updateText(newText);
        return true;
      }
    }
    return false;
  }
  
  toggleTodo(id) {
    const todo = this.findTodo(id);
    if (todo) {
      {
        todo.toggle();
        return true;
      }
    }
    return false;
  }
  
  getFilteredTodos() {
    return this.todos.filter((todo) => todo.matchesFilter(this.filter));
  }
  
  setFilter(filter) {
    this.filter = filter;
    return this.getFilteredTodos();
  }
  
  getAllTodos() {
    return this.todos.slice();
  }
  
  getActiveTodos() {
    return this.todos.filter((todo) => todo.completed == false);
  }
  
  getCompletedTodos() {
    return this.todos.filter((todo) => todo.completed);
  }
  
  getCount() {
    return { total: this.todos.length, active: this.getActiveTodos().length, completed: this.getCompletedTodos().length };
  }
  
  clear() {
    this.todos = [];
  }
  
  clearCompleted() {
    this.todos = this.getActiveTodos();
  }
  
  completeAll() {
    this.todos.forEach((todo) => todo.complete());
  }
  
  activateAll() {
    this.todos.forEach((todo) => todo.activate());
  }
  
  isEmpty() {
    return this.todos.length == 0;
  }
  
  allCompleted() {
    return this.todos.length > 0 && this.todos.every((todo) => todo.completed);
  }
  
  hasCompleted() {
    return this.todos.some((todo) => todo.completed);
  }
  
  toData() {
    return this.todos.map((todo) => todo.toData());
  }
  
}

export class FilterConfig {
  constructor(label, value) {
    this.label = label;
    this.value = value;
    this.isActive = isActive !== undefined ? isActive : false;
  }
  
  static createAll() {
    return { label: "All", value: FilterType.ALL(), isActive: false };
  }
  
  static createActive() {
    return { label: "Active", value: FilterType.ACTIVE(), isActive: false };
  }
  
  static createCompleted() {
    return { label: "Completed", value: FilterType.COMPLETED(), isActive: false };
  }
  
  static getAllFilters() {
    return [FilterConfig.createAll(), FilterConfig.createActive(), FilterConfig.createCompleted()];
  }
  
  setActive(isActive) {
    this.isActive = isActive;
  }
  
}

export class ValidationService {
  static instance = null;
  
  static getInstance() {
    if (!this.instance) {
      this.instance = new this();
    }
    return this.instance;
  }
  
  validateTodoText(text) {
    const result = { isValid: false, error: null, sanitizedText: "" };
    if (text == null) {
      {
        result.error = "Text must be a string";
        return result;
      }
    }
    const trimmed = text.trim();
    if (trimmed.length == 0) {
      {
        result.error = "Text cannot be empty";
        return result;
      }
    }
    if (trimmed.length > 500) {
      {
        result.error = "Text cannot exceed 500 characters";
        return result;
      }
    }
    result.isValid = true;
    result.sanitizedText = trimmed;
    return result;
  }
  
  validateTodoId(id) {
    if (id == null) {
      {
        return false;
      }
    }
    if (id.length == 0) {
      {
        return false;
      }
    }
    return true;
  }
  
  validateFilterType(filter) {
    if (filter == FilterType.ALL()) {
      {
        return true;
      }
    }
    if (filter == FilterType.ACTIVE()) {
      {
        return true;
      }
    }
    if (filter == FilterType.COMPLETED()) {
      {
        return true;
      }
    }
    return false;
  }
  
}
