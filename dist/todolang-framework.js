// TodoLang Framework Bundle
// Generated by TodoLang Build System

// === language\runtime\index.js ===
/**
 * TodoLang Runtime - Provides runtime support for TodoLang features
 *
 * This is a placeholder implementation for the bootstrap system.
 * The full runtime will be implemented in other tasks.
 */

export class TodoLangRuntime {
  constructor(options = {}) {
    this.options = options;
    this.modules = new Map();
    this.errorHandlers = [];
    this.performanceMetrics = [];
  }

  async initialize(config = {}) {
    this.modules = config.modules || new Map();
    this.mode = config.mode || 'development';
    this.enableDebugging = config.enableDebugging || false;

    if (this.enableDebugging) {
      console.log('ðŸ”§ TodoLang Runtime initialized in debug mode');
    }
  }

  async execute(compiledCode) {
    try {
      // In a full implementation, this would execute the compiled TodoLang code
      // For now, we'll just log that execution was attempted
      if (this.enableDebugging) {
        console.log('âš¡ Executing compiled TodoLang code...');
      }

      // Simulate code execution
      if (typeof compiledCode === 'string' && compiledCode.includes('class')) {
        // Code appears to be a class definition
        return { success: true, type: 'class' };
      }

      return { success: true, type: 'unknown' };
    } catch (error) {
      this.notifyErrorHandlers(error);
      throw error;
    }
  }

  async mount(element) {
    if (typeof window !== 'undefined' && element) {
      // In a full implementation, this would mount the TodoLang application
      if (this.enableDebugging) {
        console.log('ðŸ”— Mounting TodoLang application to DOM element');
      }

      // Placeholder mounting
      element.innerHTML = '<div>TodoLang Runtime Placeholder - Application would be mounted here</div>';
      return true;
    }
    return false;
  }

  async hotReload(modulePath, newCode) {
    if (this.enableDebugging) {
      console.log(`ðŸ”¥ Hot reloading module: ${modulePath}`);
    }

    // Update the module in our registry
    if (this.modules.has(modulePath)) {
      const module = this.modules.get(modulePath);
      module.compiledCode = newCode;
      module.lastReloaded = new Date();
    }

    // In a full implementation, this would update the running application
    return true;
  }

  onError(handler) {
    this.errorHandlers.push(handler);
  }

  onPerformanceMetric(handler) {
    this.performanceMetricHandlers = this.performanceMetricHandlers || [];
    this.performanceMetricHandlers.push(handler);
  }

  notifyErrorHandlers(error) {
    for (const handler of this.errorHandlers) {
      try {
        handler(error);
      } catch (handlerError) {
        console.error('Error in error handler:', handlerError);
      }
    }
  }

  cleanup() {
    this.modules.clear();
    this.errorHandlers = [];
    this.performanceMetrics = [];

    if (this.enableDebugging) {
      console.log('ðŸ§¹ TodoLang Runtime cleaned up');
    }
  }
}

// === framework\state\index.js ===
/**
 * Custom Reactive State Management System
 *
 * This module provides a reactive state management system that:
 * - Tracks state changes and triggers updates
 * - Implements subscription system for component re-rendering
 * - Detects state mutations and provides automatic UI synchronization
 */

/**
 * Reactive State Proxy Handler
 * Intercepts property access and mutations to trigger reactivity
 */
class ReactiveHandler {
  constructor(stateManager, path = '') {
    this.stateManager = stateManager;
    this.path = path;
  }

  get(target, property, receiver) {
    const value = Reflect.get(target, property, receiver);
    const fullPath = this.path ? `${this.path}.${property}` : property;

    // Track property access for dependency tracking
    this.stateManager._trackAccess(fullPath);

    // If the value is an object, wrap it in a reactive proxy
    if (value !== null && typeof value === 'object') {
      return new Proxy(value, new ReactiveHandler(this.stateManager, fullPath));
    }

    return value;
  }

  set(target, property, value, receiver) {
    const oldValue = target[property];
    const fullPath = this.path ? `${this.path}.${property}` : property;

    // Set the new value
    const result = Reflect.set(target, property, value, receiver);

    // Only trigger updates if the value actually changed
    if (oldValue !== value) {
      this.stateManager._notifyChange(fullPath, value, oldValue);
    }

    return result;
  }

  deleteProperty(target, property) {
    const oldValue = target[property];
    const fullPath = this.path ? `${this.path}.${property}` : property;

    const result = Reflect.deleteProperty(target, property);

    if (result) {
      this.stateManager._notifyChange(fullPath, undefined, oldValue);
    }

    return result;
  }
}

/**
 * Reactive State Container
 * Wraps state objects with reactive capabilities
 */
class ReactiveState {
  constructor(initialState, stateManager) {
    this._stateManager = stateManager;
    this._state = this._deepClone(initialState);
    this._proxy = new Proxy(this._state, new ReactiveHandler(stateManager));

    return this._proxy;
  }

  _deepClone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof Array) return obj.map(item => this._deepClone(item));

    const cloned = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        cloned[key] = this._deepClone(obj[key]);
      }
    }
    return cloned;
  }
}

/**
 * Main State Manager Class
 * Manages reactive state, subscriptions, and change notifications
 */
class TodoLangStateManager {
  constructor() {
    this._subscribers = new Map(); // path -> Set of callbacks
    this._globalSubscribers = new Set(); // Global change listeners
    this._currentlyTracking = null; // Currently tracking component
    this._dependencies = new Map(); // component -> Set of paths
    this._states = new Map(); // state id -> reactive state
    this._changeQueue = [];
    this._isProcessingChanges = false;
  }

  /**
   * Create a new reactive state object
   * @param {Object} initialState - Initial state values
   * @param {string} stateId - Optional unique identifier for the state
   * @returns {Proxy} Reactive state proxy
   */
  createState(initialState, stateId = null) {
    const reactiveState = new ReactiveState(initialState, this);

    if (stateId) {
      this._states.set(stateId, reactiveState);
    }

    return reactiveState;
  }

  /**
   * Subscribe to state changes
   * @param {Function} callback - Function to call when state changes
   * @param {string|Array} paths - Specific paths to watch (optional)
   * @returns {Function} Unsubscribe function
   */
  subscribe(callback, paths = null) {
    if (!paths) {
      // Global subscription
      this._globalSubscribers.add(callback);
      return () => this._globalSubscribers.delete(callback);
    }

    // Path-specific subscription
    const pathArray = Array.isArray(paths) ? paths : [paths];
    const unsubscribeFunctions = [];

    pathArray.forEach(path => {
      if (!this._subscribers.has(path)) {
        this._subscribers.set(path, new Set());
      }
      this._subscribers.get(path).add(callback);

      unsubscribeFunctions.push(() => {
        const subscribers = this._subscribers.get(path);
        if (subscribers) {
          subscribers.delete(callback);
          if (subscribers.size === 0) {
            this._subscribers.delete(path);
          }
        }
      });
    });

    // Return combined unsubscribe function
    return () => unsubscribeFunctions.forEach(fn => fn());
  }

  /**
   * Update state at a specific path
   * @param {string} path - Dot-notation path to update
   * @param {any} value - New value to set
   */
  updateState(path, value) {
    // Find the state object that contains this path
    for (const [stateId, state] of this._states) {
      if (this._setValueAtPath(state, path, value)) {
        return;
      }
    }

    // If no specific state found, this might be a direct property update
    throw new Error(`Cannot update state at path: ${path}. State not found.`);
  }

  /**
   * Get current state value at path
   * @param {string} path - Dot-notation path to get
   * @returns {any} Current value at path
   */
  getState(path, stateId = null) {
    if (stateId && this._states.has(stateId)) {
      return this._getValueAtPath(this._states.get(stateId), path);
    }

    // Search all states for the path
    for (const [id, state] of this._states) {
      const value = this._getValueAtPath(state, path);
      if (value !== undefined) {
        return value;
      }
    }

    return undefined;
  }

  /**
   * Start tracking dependencies for a component
   * @param {string} componentId - Unique component identifier
   */
  startTracking(componentId) {
    this._currentlyTracking = componentId;
    if (!this._dependencies.has(componentId)) {
      this._dependencies.set(componentId, new Set());
    } else {
      this._dependencies.get(componentId).clear();
    }
  }

  /**
   * Stop tracking dependencies
   */
  stopTracking() {
    this._currentlyTracking = null;
  }

  /**
   * Clear all dependencies for a component
   * @param {string} componentId - Component identifier
   */
  clearDependencies(componentId) {
    this._dependencies.delete(componentId);
  }

  /**
   * Internal method to track property access
   * @private
   */
  _trackAccess(path) {
    if (this._currentlyTracking) {
      this._dependencies.get(this._currentlyTracking).add(path);
    }
  }

  /**
   * Internal method to notify subscribers of changes
   * @private
   */
  _notifyChange(path, newValue, oldValue) {
    const change = { path, newValue, oldValue, timestamp: Date.now() };
    this._changeQueue.push(change);

    if (!this._isProcessingChanges) {
      this._processChanges();
    }
  }

  /**
   * Process queued changes and notify subscribers
   * @private
   */
  _processChanges() {
    this._isProcessingChanges = true;

    // Use microtask to batch changes
    Promise.resolve().then(() => {
      const changes = [...this._changeQueue];
      this._changeQueue = [];

      // Notify path-specific subscribers
      changes.forEach(change => {
        this._notifyPathSubscribers(change.path, change);
      });

      // Notify global subscribers
      if (changes.length > 0) {
        this._globalSubscribers.forEach(callback => {
          try {
            callback(changes);
          } catch (error) {
            console.error('Error in global state subscriber:', error);
          }
        });
      }

      this._isProcessingChanges = false;

      // Process any changes that were queued during notification
      if (this._changeQueue.length > 0) {
        this._processChanges();
      }
    });
  }

  /**
   * Notify subscribers for a specific path and its parent paths
   * @private
   */
  _notifyPathSubscribers(path, change) {
    const pathParts = path.split('.');

    // Notify subscribers for this path and all parent paths
    for (let i = pathParts.length; i > 0; i--) {
      const currentPath = pathParts.slice(0, i).join('.');
      const subscribers = this._subscribers.get(currentPath);

      if (subscribers) {
        subscribers.forEach(callback => {
          try {
            callback(change, currentPath);
          } catch (error) {
            console.error(`Error in state subscriber for path ${currentPath}:`, error);
          }
        });
      }
    }
  }

  /**
   * Set value at a dot-notation path
   * @private
   */
  _setValueAtPath(obj, path, value) {
    const parts = path.split('.');
    let current = obj;

    try {
      for (let i = 0; i < parts.length - 1; i++) {
        if (!(parts[i] in current)) {
          current[parts[i]] = {};
        }
        current = current[parts[i]];
      }

      current[parts[parts.length - 1]] = value;
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Get value at a dot-notation path
   * @private
   */
  _getValueAtPath(obj, path) {
    const parts = path.split('.');
    let current = obj;

    try {
      for (const part of parts) {
        if (current === null || current === undefined) {
          return undefined;
        }
        current = current[part];
      }
      return current;
    } catch (error) {
      return undefined;
    }
  }

  /**
   * Get debug information about the state manager
   * @returns {Object} Debug information
   */
  getDebugInfo() {
    return {
      subscriberCount: this._subscribers.size,
      globalSubscriberCount: this._globalSubscribers.size,
      stateCount: this._states.size,
      dependencyCount: this._dependencies.size,
      queuedChanges: this._changeQueue.length,
      isProcessingChanges: this._isProcessingChanges
    };
  }
}

// Export the state manager and related classes
export {
  TodoLangStateManager,
  ReactiveState,
  ReactiveHandler
};

// === framework\components\index.js ===
// Custom Component Framework and Virtual DOM
export * from './virtual-dom.js';
export * from './component.js';

// === framework\router\index.js ===
/**
 * Custom Client-Side Routing System
 *
 * This module provides a client-side routing system that:
 * - Handles URL pattern matching and route registration
 * - Manages browser history and URL state
 * - Extracts route parameters and query strings
 * - Integrates with the TodoLang component system
 */

/**
 * Route Configuration Object
 */
class Route {
  constructor(path, handler, options = {}) {
    this.path = path;
    this.handler = handler;
    this.options = options;
    this.paramNames = [];
    this.regex = this._pathToRegex(path);
  }

  /**
   * Convert path pattern to regex for matching
   * Supports parameters like /todos/:id and wildcards
   * @private
   */
  _pathToRegex(path) {
    // Escape special regex characters except for our route syntax
    let regexPath = path.replace(/[.+*?^${}()|[\]\\]/g, '\\$&');

    // Handle route parameters (:param)
    regexPath = regexPath.replace(/:([^/]+)/g, (match, paramName) => {
      this.paramNames.push(paramName);
      return '([^/]+)';
    });

    // Handle wildcards (*)
    regexPath = regexPath.replace(/\\\*/g, '(.*)');

    // Ensure exact match
    return new RegExp(`^${regexPath}$`);
  }

  /**
   * Test if this route matches the given path
   * @param {string} path - Path to test
   * @returns {Object|null} Match result with parameters or null
   */
  match(path) {
    const match = this.regex.exec(path);
    if (!match) return null;

    const params = {};
    this.paramNames.forEach((name, index) => {
      params[name] = match[index + 1];
    });

    return {
      route: this,
      params,
      path
    };
  }
}

/**
 * Query String Parser
 */
class QueryParser {
  /**
   * Parse query string into object
   * @param {string} queryString - Query string (with or without ?)
   * @returns {Object} Parsed query parameters
   */
  static parse(queryString) {
    const params = {};

    if (!queryString) return params;

    // Remove leading ? if present
    const cleanQuery = queryString.startsWith('?') ? queryString.slice(1) : queryString;

    if (!cleanQuery) return params;

    cleanQuery.split('&').forEach(pair => {
      const [key, value] = pair.split('=').map(decodeURIComponent);
      if (key) {
        params[key] = value || '';
      }
    });

    return params;
  }

  /**
   * Convert object to query string
   * @param {Object} params - Parameters to convert
   * @returns {string} Query string (without leading ?)
   */
  static stringify(params) {
    if (!params || typeof params !== 'object') return '';

    const pairs = [];
    for (const [key, value] of Object.entries(params)) {
      if (value !== null && value !== undefined) {
        pairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
      }
    }

    return pairs.join('&');
  }
}

/**
 * Browser History Manager
 */
class HistoryManager {
  constructor(router) {
    this.router = router;
    this._isNavigating = false;
    this._setupEventListeners();
  }

  /**
   * Setup browser event listeners
   * @private
   */
  _setupEventListeners() {
    // Only setup listeners if we're in a browser environment
    if (typeof window === 'undefined') return;

    // Handle browser back/forward buttons
    window.addEventListener('popstate', (event) => {
      if (!this._isNavigating) {
        const path = window.location.pathname + window.location.search;
        this.router._handleRouteChange(path, false);
      }
    });

    // Handle hash changes (for hash-based routing fallback)
    window.addEventListener('hashchange', (event) => {
      if (this.router.options.useHash) {
        const hash = window.location.hash.slice(1) || '/';
        this.router._handleRouteChange(hash, false);
      }
    });
  }

  /**
   * Push new state to history
   * @param {string} path - Path to navigate to
   * @param {Object} state - State object to store
   */
  pushState(path, state = {}) {
    if (typeof window === 'undefined') return;

    this._isNavigating = true;

    if (this.router.options.useHash) {
      window.location.hash = path;
    } else {
      window.history.pushState(state, '', path);
    }

    this._isNavigating = false;
  }

  /**
   * Replace current state in history
   * @param {string} path - Path to replace with
   * @param {Object} state - State object to store
   */
  replaceState(path, state = {}) {
    if (typeof window === 'undefined') return;

    this._isNavigating = true;

    if (this.router.options.useHash) {
      window.location.replace(`${window.location.pathname}${window.location.search}#${path}`);
    } else {
      window.history.replaceState(state, '', path);
    }

    this._isNavigating = false;
  }

  /**
   * Go back in history
   */
  back() {
    if (typeof window !== 'undefined') {
      window.history.back();
    }
  }

  /**
   * Go forward in history
   */
  forward() {
    if (typeof window !== 'undefined') {
      window.history.forward();
    }
  }

  /**
   * Go to specific history entry
   * @param {number} delta - Number of steps to go (negative for back)
   */
  go(delta) {
    if (typeof window !== 'undefined') {
      window.history.go(delta);
    }
  }
}

/**
 * Main Router Class
 */
class TodoLangRouter {
  constructor(options = {}) {
    this.options = {
      useHash: false,
      base: '',
      caseSensitive: false,
      ...options
    };

    this.routes = [];
    this.currentRoute = null;
    this.currentParams = {};
    this.currentQuery = {};
    this.beforeHooks = [];
    this.afterHooks = [];
    this.errorHandlers = [];

    this.history = new HistoryManager(this);
    this._isStarted = false;
  }

  /**
   * Add a route to the router
   * @param {string} path - Route path pattern
   * @param {Function|Object} handler - Route handler or component
   * @param {Object} options - Route options
   * @returns {TodoLangRouter} Router instance for chaining
   */
  addRoute(path, handler, options = {}) {
    const route = new Route(path, handler, options);
    this.routes.push(route);
    return this;
  }

  /**
   * Add multiple routes at once
   * @param {Array} routes - Array of route configurations
   * @returns {TodoLangRouter} Router instance for chaining
   */
  addRoutes(routes) {
    routes.forEach(({ path, handler, options }) => {
      this.addRoute(path, handler, options);
    });
    return this;
  }

  /**
   * Navigate to a specific path
   * @param {string} path - Path to navigate to
   * @param {Object} options - Navigation options
   */
  navigate(path, options = {}) {
    const {
      replace = false,
      state = {},
      trigger = true
    } = options;

    // Normalize path
    const normalizedPath = this._normalizePath(path);

    // Update browser history
    if (replace) {
      this.history.replaceState(normalizedPath, state);
    } else {
      this.history.pushState(normalizedPath, state);
    }

    // Trigger route change if requested
    if (trigger) {
      this._handleRouteChange(normalizedPath, true);
    }
  }

  /**
   * Replace current route
   * @param {string} path - Path to replace with
   * @param {Object} options - Navigation options
   */
  replace(path, options = {}) {
    this.navigate(path, { ...options, replace: true });
  }

  /**
   * Go back in history
   */
  back() {
    this.history.back();
  }

  /**
   * Go forward in history
   */
  forward() {
    this.history.forward();
  }

  /**
   * Get current route information
   * @returns {Object} Current route information
   */
  getCurrentRoute() {
    return {
      route: this.currentRoute,
      params: { ...this.currentParams },
      query: { ...this.currentQuery },
      path: this._getCurrentPath()
    };
  }

  /**
   * Get current path from browser
   * @returns {string} Current path
   * @private
   */
  _getCurrentPath() {
    if (typeof window === 'undefined') return '/';

    if (this.options.useHash) {
      return window.location.hash.slice(1) || '/';
    } else {
      return window.location.pathname + window.location.search;
    }
  }

  /**
   * Start the router
   * @param {string} initialPath - Initial path to navigate to
   */
  start(initialPath = null) {
    if (this._isStarted) {
      console.warn('Router is already started');
      return;
    }

    this._isStarted = true;

    // Navigate to initial path or current browser path
    const startPath = initialPath || this._getCurrentPath();
    this._handleRouteChange(startPath, false);
  }

  /**
   * Stop the router
   */
  stop() {
    this._isStarted = false;
    // Event listeners are cleaned up automatically when the page unloads
  }

  /**
   * Add before navigation hook
   * @param {Function} hook - Hook function
   */
  beforeEach(hook) {
    this.beforeHooks.push(hook);
  }

  /**
   * Add after navigation hook
   * @param {Function} hook - Hook function
   */
  afterEach(hook) {
    this.afterHooks.push(hook);
  }

  /**
   * Add error handler
   * @param {Function} handler - Error handler function
   */
  onError(handler) {
    this.errorHandlers.push(handler);
  }

  /**
   * Handle route changes
   * @param {string} path - New path
   * @param {boolean} isUserNavigation - Whether this is user-initiated navigation
   * @private
   */
  async _handleRouteChange(path, isUserNavigation) {
    if (!this._isStarted) return;

    try {
      // Parse path and query
      const [pathname, queryString] = path.split('?');
      const normalizedPath = this._normalizePath(pathname);
      const query = QueryParser.parse(queryString);

      // Find matching route
      const matchResult = this._findMatchingRoute(normalizedPath);

      if (!matchResult) {
        this._handleNotFound(normalizedPath);
        return;
      }

      const { route, params } = matchResult;

      // Create route context
      const to = {
        route,
        params,
        query,
        path: normalizedPath,
        fullPath: path
      };

      const from = {
        route: this.currentRoute,
        params: this.currentParams,
        query: this.currentQuery,
        path: this.currentRoute ? this.currentRoute.path : null
      };

      // Run before hooks
      const shouldContinue = await this._runBeforeHooks(to, from);
      if (!shouldContinue) return;

      // Update current route info
      this.currentRoute = route;
      this.currentParams = params;
      this.currentQuery = query;

      // Execute route handler
      await this._executeRouteHandler(route, to, from);

      // Run after hooks
      await this._runAfterHooks(to, from);

    } catch (error) {
      this._handleError(error, path);
    }
  }

  /**
   * Find matching route for path
   * @param {string} path - Path to match
   * @returns {Object|null} Match result or null
   * @private
   */
  _findMatchingRoute(path) {
    for (const route of this.routes) {
      const match = route.match(path);
      if (match) {
        return match;
      }
    }
    return null;
  }

  /**
   * Execute route handler
   * @param {Route} route - Matched route
   * @param {Object} to - Destination route info
   * @param {Object} from - Source route info
   * @private
   */
  async _executeRouteHandler(route, to, from) {
    if (typeof route.handler === 'function') {
      await route.handler(to, from);
    } else if (route.handler && typeof route.handler.render === 'function') {
      // Handle component-like objects
      await route.handler.render(to, from);
    }
  }

  /**
   * Run before navigation hooks
   * @param {Object} to - Destination route info
   * @param {Object} from - Source route info
   * @returns {boolean} Whether to continue navigation
   * @private
   */
  async _runBeforeHooks(to, from) {
    for (const hook of this.beforeHooks) {
      try {
        const result = await hook(to, from);
        if (result === false) {
          return false;
        }
      } catch (error) {
        this._handleError(error, to.fullPath);
        return false;
      }
    }
    return true;
  }

  /**
   * Run after navigation hooks
   * @param {Object} to - Destination route info
   * @param {Object} from - Source route info
   * @private
   */
  async _runAfterHooks(to, from) {
    for (const hook of this.afterHooks) {
      try {
        await hook(to, from);
      } catch (error) {
        this._handleError(error, to.fullPath);
      }
    }
  }

  /**
   * Handle 404 not found
   * @param {string} path - Path that wasn't found
   * @private
   */
  _handleNotFound(path) {
    const error = new Error(`Route not found: ${path}`);
    error.code = 'ROUTE_NOT_FOUND';
    error.path = path;
    this._handleError(error, path);
  }

  /**
   * Handle routing errors
   * @param {Error} error - Error that occurred
   * @param {string} path - Path where error occurred
   * @private
   */
  _handleError(error, path) {
    console.error('Router error:', error);

    // Try error handlers
    for (const handler of this.errorHandlers) {
      try {
        handler(error, path);
        return;
      } catch (handlerError) {
        console.error('Error in error handler:', handlerError);
      }
    }

    // Default error handling
    console.error(`Unhandled router error at ${path}:`, error);
  }

  /**
   * Normalize path by removing base and handling case sensitivity
   * @param {string} path - Path to normalize
   * @returns {string} Normalized path
   * @private
   */
  _normalizePath(path) {
    let normalized = path;

    // Remove base path if configured
    if (this.options.base && normalized.startsWith(this.options.base)) {
      normalized = normalized.slice(this.options.base.length);
    }

    // Ensure path starts with /
    if (!normalized.startsWith('/')) {
      normalized = '/' + normalized;
    }

    // Handle case sensitivity
    if (!this.options.caseSensitive) {
      normalized = normalized.toLowerCase();
    }

    return normalized;
  }

  /**
   * Build URL with query parameters
   * @param {string} path - Base path
   * @param {Object} query - Query parameters
   * @returns {string} Complete URL
   */
  buildUrl(path, query = {}) {
    let url = this._normalizePath(path);

    const queryString = QueryParser.stringify(query);
    if (queryString) {
      url += '?' + queryString;
    }

    return url;
  }

  /**
   * Get debug information about the router
   * @returns {Object} Debug information
   */
  getDebugInfo() {
    return {
      isStarted: this._isStarted,
      routeCount: this.routes.length,
      currentRoute: this.currentRoute?.path,
      currentParams: this.currentParams,
      currentQuery: this.currentQuery,
      options: this.options
    };
  }
}

// Export the router and related classes
export {
  TodoLangRouter,
  Route,
  QueryParser,
  HistoryManager
};

// === framework\storage\index.js ===
/**
 * Custom Storage Abstraction Layer
 * Provides a robust wrapper around localStorage with error handling,
 * serialization, graceful degradation, and quota management
 */

import { globalErrorReporter } from '../../debug/error-reporter.js';

class StorageError extends Error {
  constructor(message, code, originalError = null, userMessage = null) {
    super(message);
    this.name = 'StorageError';
    this.code = code;
    this.originalError = originalError;
    this.userMessage = userMessage || this._generateUserMessage(code);
    this.timestamp = new Date().toISOString();
  }

  /**
   * Generate user-friendly error messages
   */
  _generateUserMessage(code) {
    const userMessages = {
      'QUOTA_EXCEEDED': 'Storage space is full. Please clear some data or try again later.',
      'STORAGE_UNAVAILABLE': 'Data storage is not available. Your changes may not be saved.',
      'SERIALIZATION_ERROR': 'Unable to save data due to formatting issues.',
      'DESERIALIZATION_ERROR': 'Unable to load saved data. The data may be corrupted.',
      'INVALID_KEY': 'Invalid data identifier provided.',
      'STORAGE_FAILED': 'Failed to save data. Please try again.',
      'REMOVAL_FAILED': 'Failed to delete data. Please try again.',
      'CLEAR_FAILED': 'Failed to clear storage. Please try again.',
      'NETWORK_ERROR': 'Network connection issue. Please check your connection.',
      'PERMISSION_DENIED': 'Permission denied. Please check your browser settings.',
      'TIMEOUT': 'Operation timed out. Please try again.'
    };

    return userMessages[code] || 'An unexpected storage error occurred. Please try again.';
  }

  /**
   * Get user-friendly error message
   */
  getUserMessage() {
    return this.userMessage;
  }

  /**
   * Get error details for debugging
   */
  getDebugInfo() {
    return {
      message: this.message,
      code: this.code,
      userMessage: this.userMessage,
      timestamp: this.timestamp,
      originalError: this.originalError ? {
        name: this.originalError.name,
        message: this.originalError.message,
        stack: this.originalError.stack
      } : null
    };
  }
}

class StorageService {
  constructor(options = {}) {
    this.isAvailable = this._checkAvailability();
    this.fallbackStorage = new Map();
    this.quotaWarningThreshold = options.quotaWarningThreshold || 0.8; // 80% of quota
    this.maxRetries = options.maxRetries || 3;
    this.enableErrorReporting = options.enableErrorReporting !== false;
    this.userErrorCallback = options.onUserError || null;
    this.errorHistory = [];
    this.maxErrorHistory = 50;
  }

  /**
   * Check if localStorage is available and functional
   */
  _checkAvailability() {
    try {
      const testKey = '__storage_test__';
      localStorage.setItem(testKey, 'test');
      localStorage.removeItem(testKey);
      return true;
    } catch (error) {
      console.warn('localStorage is not available, falling back to in-memory storage:', error.message);
      return false;
    }
  }

  /**
   * Serialize data for storage
   */
  _serialize(data) {
    try {
      return JSON.stringify(data);
    } catch (error) {
      throw new StorageError(
        'Failed to serialize data for storage',
        'SERIALIZATION_ERROR',
        error
      );
    }
  }

  /**
   * Deserialize data from storage
   */
  _deserialize(data) {
    if (data === null || data === undefined) {
      return null;
    }

    try {
      return JSON.parse(data);
    } catch (error) {
      throw new StorageError(
        'Failed to deserialize data from storage',
        'DESERIALIZATION_ERROR',
        error
      );
    }
  }

  /**
   * Get storage quota information
   */
  async getQuotaInfo() {
    if (!this.isAvailable) {
      return {
        used: this.fallbackStorage.size,
        total: Infinity,
        available: Infinity,
        percentage: 0
      };
    }

    try {
      if ('storage' in navigator && 'estimate' in navigator.storage) {
        const estimate = await navigator.storage.estimate();
        return {
          used: estimate.usage || 0,
          total: estimate.quota || 0,
          available: (estimate.quota || 0) - (estimate.usage || 0),
          percentage: estimate.quota ? (estimate.usage / estimate.quota) : 0
        };
      }
    } catch (error) {
      console.warn('Could not get storage quota information:', error.message);
    }

    // Fallback: estimate based on localStorage content
    const used = this._estimateLocalStorageSize();
    const estimated_total = 5 * 1024 * 1024; // Assume 5MB typical limit

    return {
      used,
      total: estimated_total,
      available: estimated_total - used,
      percentage: used / estimated_total
    };
  }

  /**
   * Estimate localStorage size in bytes
   */
  _estimateLocalStorageSize() {
    let total = 0;
    try {
      for (let key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
          total += key.length + (localStorage[key] || '').length;
        }
      }
    } catch (error) {
      console.warn('Could not estimate localStorage size:', error.message);
    }
    return total * 2; // UTF-16 encoding approximation
  }

  /**
   * Check if storage is approaching quota limit
   */
  async _checkQuotaWarning() {
    const quotaInfo = await this.getQuotaInfo();
    if (quotaInfo.percentage > this.quotaWarningThreshold) {
      console.warn(`Storage quota warning: ${Math.round(quotaInfo.percentage * 100)}% used`);
      return true;
    }
    return false;
  }

  /**
   * Store data with key
   */
  async setItem(key, value, options = {}) {
    const { retries = this.maxRetries, skipQuotaCheck = false } = options;

    if (!key || typeof key !== 'string') {
      throw new StorageError('Invalid key provided', 'INVALID_KEY');
    }

    const serializedValue = this._serialize(value);

    // Check quota before storing large items
    if (!skipQuotaCheck && serializedValue.length > 1024) {
      await this._checkQuotaWarning();
    }

    // Use fallback storage if localStorage is not available
    if (!this.isAvailable) {
      this.fallbackStorage.set(key, serializedValue);
      return;
    }

    let lastError;
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        localStorage.setItem(key, serializedValue);
        return;
      } catch (error) {
        lastError = error;

        if (error.name === 'QuotaExceededError' || error.code === 22) {
          // Try to free up space
          if (attempt < retries) {
            await this._performCleanup();
            continue;
          }
          throw new StorageError(
            'Storage quota exceeded and cleanup failed',
            'QUOTA_EXCEEDED',
            error
          );
        }

        // For other errors, don't retry
        break;
      }
    }

    throw new StorageError(
      `Failed to store item after ${retries + 1} attempts`,
      'STORAGE_FAILED',
      lastError
    );
  }

  /**
   * Retrieve data by key
   */
  getItem(key, defaultValue = null) {
    if (!key || typeof key !== 'string') {
      throw new StorageError('Invalid key provided', 'INVALID_KEY');
    }

    try {
      let rawValue;

      if (this.isAvailable) {
        rawValue = localStorage.getItem(key);
      } else {
        rawValue = this.fallbackStorage.get(key);
      }

      if (rawValue === null || rawValue === undefined) {
        return defaultValue;
      }

      return this._deserialize(rawValue);
    } catch (error) {
      if (error instanceof StorageError) {
        throw error;
      }

      console.warn(`Failed to retrieve item '${key}':`, error.message);
      return defaultValue;
    }
  }

  /**
   * Remove item by key
   */
  removeItem(key) {
    if (!key || typeof key !== 'string') {
      throw new StorageError('Invalid key provided', 'INVALID_KEY');
    }

    try {
      if (this.isAvailable) {
        localStorage.removeItem(key);
      } else {
        this.fallbackStorage.delete(key);
      }
    } catch (error) {
      throw new StorageError(
        `Failed to remove item '${key}'`,
        'REMOVAL_FAILED',
        error
      );
    }
  }

  /**
   * Check if key exists
   */
  hasItem(key) {
    if (!key || typeof key !== 'string') {
      return false;
    }

    try {
      if (this.isAvailable) {
        return localStorage.getItem(key) !== null;
      } else {
        return this.fallbackStorage.has(key);
      }
    } catch (error) {
      console.warn(`Failed to check existence of '${key}':`, error.message);
      return false;
    }
  }

  /**
   * Get all keys
   */
  getAllKeys() {
    try {
      if (this.isAvailable) {
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key !== null) {
            keys.push(key);
          }
        }
        return keys;
      } else {
        return Array.from(this.fallbackStorage.keys());
      }
    } catch (error) {
      console.warn('Failed to get all keys:', error.message);
      return [];
    }
  }

  /**
   * Clear all storage
   */
  clear() {
    try {
      if (this.isAvailable) {
        localStorage.clear();
      } else {
        this.fallbackStorage.clear();
      }
    } catch (error) {
      throw new StorageError('Failed to clear storage', 'CLEAR_FAILED', error);
    }
  }

  /**
   * Get storage statistics
   */
  async getStats() {
    const quotaInfo = await this.getQuotaInfo();
    const keys = this.getAllKeys();

    return {
      isAvailable: this.isAvailable,
      itemCount: keys.length,
      quota: quotaInfo,
      keys: keys
    };
  }

  /**
   * Perform cleanup to free up storage space
   */
  async _performCleanup() {
    console.log('Performing storage cleanup...');

    // Strategy 1: Remove items with specific cleanup patterns
    const keysToClean = this.getAllKeys().filter(key =>
      key.startsWith('temp_') ||
      key.startsWith('cache_') ||
      key.includes('_expired_')
    );

    for (const key of keysToClean) {
      try {
        this.removeItem(key);
      } catch (error) {
        console.warn(`Failed to remove cleanup key '${key}':`, error.message);
      }
    }

    // Strategy 2: Remove oldest items if we have timestamp-based keys
    const timestampKeys = this.getAllKeys()
      .filter(key => key.includes('_timestamp_'))
      .sort(); // Assuming timestamp is in sortable format

    const itemsToRemove = Math.min(5, Math.floor(timestampKeys.length * 0.1));
    for (let i = 0; i < itemsToRemove; i++) {
      try {
        this.removeItem(timestampKeys[i]);
      } catch (error) {
        console.warn(`Failed to remove old key '${timestampKeys[i]}':`, error.message);
      }
    }

    console.log(`Cleanup completed. Removed ${keysToClean.length + itemsToRemove} items.`);
  }

  /**
   * Batch operations for efficiency
   */
  async setMultiple(items) {
    const results = [];
    for (const [key, value] of Object.entries(items)) {
      try {
        await this.setItem(key, value);
        results.push({ key, success: true });
      } catch (error) {
        results.push({ key, success: false, error: error.message });
      }
    }
    return results;
  }

  /**
   * Get multiple items at once
   */
  getMultiple(keys, defaultValue = null) {
    const results = {};
    for (const key of keys) {
      try {
        results[key] = this.getItem(key, defaultValue);
      } catch (error) {
        results[key] = defaultValue;
        console.warn(`Failed to get item '${key}':`, error.message);
      }
    }
    return results;
  }

  /**
   * Handle storage error with user-friendly messaging
   */
  _handleStorageError(error, operation = 'storage operation') {
    // Add to error history
    this.errorHistory.push({
      error: error,
      operation: operation,
      timestamp: new Date().toISOString(),
      isAvailable: this.isAvailable
    });

    // Keep error history within limits
    if (this.errorHistory.length > this.maxErrorHistory) {
      this.errorHistory = this.errorHistory.slice(-this.maxErrorHistory);
    }

    // Report error if enabled
    if (this.enableErrorReporting) {
      globalErrorReporter.reportRuntimeError(error, {
        component: 'StorageService',
        operation: operation,
        isAvailable: this.isAvailable,
        fallbackStorageSize: this.fallbackStorage.size
      });
    }

    // Call user error callback if provided
    if (this.userErrorCallback) {
      try {
        this.userErrorCallback(error, operation);
      } catch (callbackError) {
        console.error('Error in user error callback:', callbackError);
      }
    }

    return error;
  }

  /**
   * Get user-friendly error message for display
   */
  getUserErrorMessage(error) {
    if (error instanceof StorageError) {
      return error.getUserMessage();
    }

    // Fallback for non-StorageError instances
    if (error.name === 'QuotaExceededError' || error.code === 22) {
      return 'Storage space is full. Please clear some data or try again later.';
    }

    if (error.name === 'SecurityError') {
      return 'Permission denied. Please check your browser settings.';
    }

    return 'An unexpected storage error occurred. Please try again.';
  }

  /**
   * Get error history for debugging
   */
  getErrorHistory() {
    return this.errorHistory.slice(); // Return copy
  }

  /**
   * Clear error history
   */
  clearErrorHistory() {
    this.errorHistory = [];
  }

  /**
   * Get error statistics
   */
  getErrorStats() {
    const now = Date.now();
    const oneHourAgo = now - (60 * 60 * 1000);
    const oneDayAgo = now - (24 * 60 * 60 * 1000);

    const recentErrors = this.errorHistory.filter(entry =>
      new Date(entry.timestamp).getTime() > oneHourAgo
    );

    const dailyErrors = this.errorHistory.filter(entry =>
      new Date(entry.timestamp).getTime() > oneDayAgo
    );

    const errorTypes = {};
    for (const entry of this.errorHistory) {
      const type = entry.error.code || entry.error.name || 'unknown';
      errorTypes[type] = (errorTypes[type] || 0) + 1;
    }

    return {
      total: this.errorHistory.length,
      recent: recentErrors.length,
      daily: dailyErrors.length,
      types: errorTypes,
      isAvailable: this.isAvailable,
      fallbackStorageSize: this.fallbackStorage.size
    };
  }

  /**
   * Test storage functionality
   */
  async testStorage() {
    const testResults = {
      isAvailable: this.isAvailable,
      canWrite: false,
      canRead: false,
      canDelete: false,
      quotaInfo: null,
      errors: []
    };

    const testKey = '__storage_test_' + Date.now();
    const testValue = { test: true, timestamp: Date.now() };

    try {
      // Test write
      await this.setItem(testKey, testValue);
      testResults.canWrite = true;

      // Test read
      const retrieved = this.getItem(testKey);
      testResults.canRead = retrieved && retrieved.test === true;

      // Test delete
      this.removeItem(testKey);
      testResults.canDelete = !this.hasItem(testKey);

      // Get quota info
      testResults.quotaInfo = await this.getQuotaInfo();

    } catch (error) {
      testResults.errors.push({
        message: error.message,
        code: error.code,
        userMessage: this.getUserErrorMessage(error)
      });
    }

    return testResults;
  }

  /**
   * Recover from storage errors
   */
  async recoverFromError(errorType) {
    switch (errorType) {
      case 'QUOTA_EXCEEDED':
        await this._performCleanup();
        return 'Storage cleanup completed. Please try again.';

      case 'STORAGE_UNAVAILABLE':
        this.isAvailable = this._checkAvailability();
        return this.isAvailable ?
          'Storage is now available.' :
          'Storage is still unavailable. Using temporary storage.';

      case 'DESERIALIZATION_ERROR':
        // Could implement data recovery strategies here
        return 'Data corruption detected. Some data may be lost.';

      default:
        return 'Recovery attempt completed. Please try again.';
    }
  }
}

// Export the service class and error class
export { StorageService, StorageError };

